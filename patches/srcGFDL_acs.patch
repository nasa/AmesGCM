diff --git a/driver/mars/atmosphere.F90 b/driver/mars/atmosphere.F90
new file mode 100644
index 0000000..015e54b
--- /dev/null
+++ b/driver/mars/atmosphere.F90
@@ -0,0 +1,2046 @@
+!***********************************************************************
+!*                   GNU Lesser General Public License
+!*
+!* This file is part of the FV3 dynamical core.
+!*
+!* The FV3 dynamical core is free software: you can redistribute it
+!* and/or modify it under the terms of the
+!* GNU Lesser General Public License as published by the
+!* Free Software Foundation, either version 3 of the License, or
+!* (at your option) any later version.
+!*
+!* The FV3 dynamical core is distributed in the hope that it will be
+!* useful, but WITHOUT ANYWARRANTY; without even the implied warranty
+!* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+!* See the GNU General Public License for more details.
+!*
+!* You should have received a copy of the GNU Lesser General Public
+!* License along with the FV3 dynamical core.
+!* If not, see <http://www.gnu.org/licenses/>.
+!***********************************************************************
+module atmosphere_mod
+#include <fms_platform.h>
+
+!-----------------------------------------------------------------------
+!
+! Interface for Cubed_Sphere fv dynamical core
+!
+!-----------------------------------------------------------------------
+
+!-----------------
+! FMS modules:
+!-----------------
+#ifndef MARS_GCM
+use atmos_co2_mod,      only: atmos_co2_rad, co2_radiation_override
+#endif
+use block_control_mod,      only: block_control_type
+use constants_mod,      only: cp_air, rdgas, grav, rvgas, kappa, pi, &
+                              SECONDS_PER_DAY
+use time_manager_mod,       only: time_type, get_time, set_time, operator(+), &
+                                  operator(-), operator(/), time_type_to_real
+use fms_mod,                only: file_exist, open_namelist_file,    &
+                                  close_file, error_mesg, FATAL,     &
+                                  check_nml_error, stdlog,           &
+                                  write_version_number,              &
+                                  set_domain,   &
+                                  mpp_clock_id, mpp_clock_begin,     &
+                                  mpp_clock_end, CLOCK_SUBCOMPONENT, &
+                                  clock_flag_default, nullify_domain
+use mpp_mod,                only: mpp_error, stdout, FATAL, WARNING, NOTE, &
+                                  input_nml_file, mpp_root_pe,    &
+                                  mpp_npes, mpp_pe, mpp_chksum,   &
+                                  mpp_get_current_pelist,         &
+                                  mpp_set_current_pelist, mpp_sync
+use mpp_parameter_mod,      only: EUPDATE, WUPDATE, SUPDATE, NUPDATE
+use mpp_domains_mod,        only: domain2d, mpp_update_domains
+use xgrid_mod,              only: grid_box_type
+!miz
+use diag_manager_mod,       only: register_diag_field, send_data
+use field_manager_mod,      only: MODEL_ATMOS
+use tracer_manager_mod,     only: get_tracer_index, get_number_tracers, &
+                                  NO_TRACER, get_tracer_names
+#if defined(MARS_GCM) || defined(VENUS_GCM) || defined(STRAT_GCM)
+use mars_physics_mod,   only: mars_physics_init, mars_physics_end
+use fv_mars_interface_mod,   only:  get_cubed_sphere_mars
+use mars_physics_update_mod
+#else
+use physics_driver_mod,     only: surf_diff_type
+use physics_types_mod,      only: physics_type, &
+                                  physics_tendency_type
+use radiation_types_mod,    only: radiation_type, compute_g_avg
+use atmos_cmip_diag_mod,    only: atmos_cmip_diag_init, &
+                                  register_cmip_diag_field_3d, &
+                                  send_cmip_data_3d, cmip_diag_id_type, &
+                                  query_cmip_diag_id
+use atmos_global_diag_mod,  only: atmos_global_diag_init, &
+                                  atmos_global_diag_end
+#endif
+
+!-----------------
+! FV core modules:
+!-----------------
+use fv_arrays_mod,      only: fv_atmos_type
+use fv_control_mod,     only: fv_control_init, fv_end, ngrids
+use fv_eta_mod,         only: get_eta_level
+use fv_dynamics_mod,    only: fv_dynamics
+use fv_nesting_mod,     only: twoway_nesting
+use fv_diagnostics_mod, only: fv_diag_init, fv_diag, fv_time, prt_maxmin, prt_height
+#ifndef MARS_GCM
+use fv_cmip_diag_mod,   only: fv_cmip_diag_init, fv_cmip_diag, fv_cmip_diag_end
+#endif
+use fv_restart_mod,     only: fv_restart, fv_write_restart
+use fv_timing_mod,      only: timing_on, timing_off
+use fv_mp_mod,          only: is_master
+use fv_sg_mod,          only: fv_subgrid_z
+use fv_update_phys_mod, only: fv_update_phys
+use fv_io_mod,          only: fv_io_register_nudge_restart
+use fv_regional_mod,    only: start_regional_restart, read_new_bc_data
+use fv_regional_mod,    only: a_step, p_step
+use fv_regional_mod,    only: current_time_in_seconds
+#ifndef MARS_GCM
+#if defined (ATMOS_NUDGE)
+use atmos_nudge_mod,      only: atmos_nudge_init, atmos_nudge_end
+#elif defined (CLIMATE_NUDGE)
+use fv_climate_nudge_mod, only: fv_climate_nudge_init,fv_climate_nudge_end
+#elif defined (ADA_NUDGE)
+use fv_ada_nudge_mod,     only: fv_ada_nudge_init, fv_ada_nudge_end
+#else
+use fv_nwp_nudge_mod,     only: fv_nwp_nudge_init, fv_nwp_nudge_end, do_adiabatic_init
+use amip_interp_mod,      only: forecast_mode
+#endif
+#endif
+
+use mpp_domains_mod, only:  mpp_get_data_domain, mpp_get_compute_domain
+use gfdl_mp_mod,        only: gfdl_mp_init, gfdl_mp_end
+use coarse_graining_mod, only: coarse_graining_init
+use coarse_grained_diagnostics_mod, only: fv_coarse_diag_init, fv_coarse_diag
+use coarse_grained_restart_files_mod, only: fv_coarse_restart_init
+
+implicit none
+private
+
+#ifdef MARS_GCM
+public :: atmosphere_init, atmosphere_end, atmosphere, atmosphere_domain
+#else
+!--- driver routines
+public :: atmosphere_init, atmosphere_end, atmosphere_restart, &
+          atmosphere_dynamics, atmosphere_state_update
+
+!--- utility routines
+public :: atmosphere_resolution, atmosphere_boundary, &
+          atmosphere_grid_center, atmosphere_domain, &
+          atmosphere_cell_area, atmosphere_control_data, &
+          atmosphere_pref, &
+          get_atmosphere_axes, get_bottom_mass, &
+          get_bottom_wind, get_stock_pe, &
+          set_atmosphere_pelist, reset_atmos_tracers
+
+!--- physics/radiation data exchange routines
+public :: atmos_radiation_driver_inputs, atmos_physics_driver_inputs
+#endif
+
+!-----------------------------------------------------------------------
+! version number of this module
+! Include variable "version" to be written to log file.
+#include<file_version.h>
+character(len=20)   :: mod_name = 'GFDL/atmosphere_mod'
+
+!---- private data ----
+  type (time_type) :: Time_step_atmos
+  public Atm
+
+  !These are convenience variables for local use only, and are set to values in Atm%
+  real    :: dt_atmos
+  real    :: zvir
+  integer :: npx, npy, npz, ncnst, pnats
+  integer :: isc, iec, jsc, jec
+  integer :: isd, ied, jsd, jed
+  integer :: nq                       ! transported tracers
+  integer :: sec, seconds, days
+  integer :: id_dynam, id_fv_diag, id_subgridz, id_phys
+  logical :: cold_start = .false.       ! read in initial condition
+
+  integer, dimension(:), allocatable :: id_tracerdt_dyn
+  integer :: num_tracers = 0
+
+!miz
+#ifndef MARS_GCM
+!miz
+  type(cmip_diag_id_type) :: ID_tnta, ID_tnhusa, ID_tnt, ID_tnhus
+#endif
+  integer :: id_udt_dyn, id_vdt_dyn, id_tdt_dyn, id_qdt_dyn
+  integer :: id_qldt_dyn, id_qidt_dyn, id_qadt_dyn
+  logical :: used
+  character(len=64) :: field
+  real, allocatable :: ttend(:,:,:)
+  real, allocatable :: qtendyyf(:,:,:,:)
+  real, allocatable :: qtend(:,:,:,:)
+  real              :: mv = -1.e10   ! missing value for diagnostics
+  integer :: sphum, liq_wat, rainwat, ice_wat, snowwat, graupel  !condensate species
+  integer :: cld_amt
+!miz
+
+  integer :: mygrid = 1
+  integer :: p_split = 1
+  integer, allocatable :: pelist(:)
+  logical, allocatable :: grids_on_this_pe(:)
+  type(fv_atmos_type), allocatable, target :: Atm(:)
+
+  real, parameter:: w0_big = 60.  ! to prevent negative w-tracer diffusion
+
+!---dynamics tendencies for use in fv_subgrid_z and during fv_update_phys
+  real, allocatable, dimension(:,:,:)   :: u_dt, v_dt, t_dt, qv_dt
+  real, allocatable, dimension(:,:,:,:) :: q_dt
+  real, allocatable :: pref(:,:), dum1d(:)
+#ifdef MARS_GCM
+  real, allocatable:: qratio(:,:,:)
+#endif
+
+!---need to define do_adiabatic_init to satisfy a reference when nwp_nudge is not the default
+#if defined(ATMOS_NUDGE) || defined(CLIMATE_NUDGE) || defined(ADA_NUDGE)
+   logical :: do_adiabatic_init
+#endif
+
+  integer, parameter :: kind_phys=8
+
+contains
+
+
+#ifdef MARS_GCM || defined(VENUS_GCM) || defined(STRAT_GCM)
+
+ subroutine atmosphere_init (Time_init, Time, Time_step)
+   type (time_type),      intent(in)    :: Time_init, Time, Time_step
+
+!--- local variables ---
+   integer :: i, n
+   integer :: itrac
+   logical :: do_atmos_nudge
+   character(len=32) :: tracer_name, tracer_units
+   real :: ps1, ps2
+   integer  k
+   real,  allocatable   ::   p_std(:)
+
+   integer :: nlunit = 9999
+   character (len = 64) :: fn_nml = 'input.nml'
+
+   !For regional
+   a_step = 0
+   current_time_in_seconds = time_type_to_real( Time - Time_init )
+   if (mpp_pe() == 0) write(0,"('atmosphere_init: current_time_seconds = ',f9.1)")current_time_in_seconds
+
+                    call timing_on('ATMOS_INIT')
+   allocate(pelist(mpp_npes()))
+   call mpp_get_current_pelist(pelist)
+
+   call get_number_tracers(MODEL_ATMOS, num_prog= num_tracers)
+
+   zvir = 0.
+
+!---- compute physics/atmos time step in seconds ----
+
+   Time_step_atmos = Time_step
+   call get_time (Time_step_atmos, sec)
+   dt_atmos = real(sec)
+
+!----- initialize FV dynamical core -----
+   !NOTE do we still need the second file_exist call?
+   cold_start = (.not.file_exist('INPUT/fv_core.res.nc') .and. .not.file_exist('INPUT/fv_core.res.tile1.nc'))
+
+   call fv_control_init( Atm, dt_atmos, mygrid, grids_on_this_pe, p_split )  ! allocates Atm components; sets mygrid
+
+   if (Atm(mygrid)%coarse_graining%write_coarse_restart_files .or. &
+       Atm(mygrid)%coarse_graining%write_coarse_diagnostics) then
+      call coarse_graining_init(Atm(mygrid)%flagstruct%npx, Atm(mygrid)%npz, &
+           Atm(mygrid)%layout, Atm(mygrid)%bd%is, Atm(mygrid)%bd%ie, &
+           Atm(mygrid)%bd%js, Atm(mygrid)%bd%je, Atm(mygrid)%coarse_graining%factor, &
+           Atm(mygrid)%coarse_graining%nx_coarse, &
+           Atm(mygrid)%coarse_graining%strategy, &
+           Atm(mygrid)%coarse_graining%domain)
+   endif
+
+   Atm(mygrid)%Time_init = Time_init
+
+!----- write version and namelist to log file -----
+   call write_version_number ( mod_name, version )
+
+!-----------------------------------
+
+   npx   = Atm(mygrid)%npx
+   npy   = Atm(mygrid)%npy
+   npz   = Atm(mygrid)%npz
+   ncnst = Atm(mygrid)%ncnst
+   pnats = Atm(mygrid)%flagstruct%pnats
+
+   isc = Atm(mygrid)%bd%isc
+   iec = Atm(mygrid)%bd%iec
+   jsc = Atm(mygrid)%bd%jsc
+   jec = Atm(mygrid)%bd%jec
+
+   isd = isc - Atm(mygrid)%bd%ng
+   ied = iec + Atm(mygrid)%bd%ng
+   jsd = jsc - Atm(mygrid)%bd%ng
+   jed = jec + Atm(mygrid)%bd%ng
+
+   nq = ncnst-pnats
+   sphum   = get_tracer_index (MODEL_ATMOS, 'sphum' )
+   liq_wat = get_tracer_index (MODEL_ATMOS, 'liq_wat' )
+   ice_wat = get_tracer_index (MODEL_ATMOS, 'ice_wat' )
+   rainwat = get_tracer_index (MODEL_ATMOS, 'rainwat' )
+   snowwat = get_tracer_index (MODEL_ATMOS, 'snowwat' )
+   graupel = get_tracer_index (MODEL_ATMOS, 'graupel' )
+   cld_amt = get_tracer_index (MODEL_ATMOS, 'cld_amt' )
+
+   if (max(sphum,liq_wat,ice_wat,rainwat,snowwat,graupel) > Atm(mygrid)%flagstruct%nwat) then
+      call mpp_error (FATAL,' atmosphere_init: condensate species are not first in the list of &
+                            &tracers defined in the field_table')
+   endif
+
+   ! Allocate grid variables to be used to calculate gradient in 2nd order flux exchange
+   ! This data is only needed for the COARSEST grid.
+   !call switch_current_Atm(Atm(mygrid))
+   call set_domain(Atm(mygrid)%domain)
+
+!----- allocate and zero out the dynamics (and accumulated) tendencies
+   allocate( u_dt(isd:ied,jsd:jed,npz), &
+             v_dt(isd:ied,jsd:jed,npz), &
+             t_dt(isc:iec,jsc:jec,npz), &
+             qv_dt(isc:iec,jsc:jec,npz), &
+             q_dt(isc:iec,jsc:jec,npz,nq) )
+   allocate( qratio(isc:iec,jsc:jec,npz) )
+!--- allocate pref
+   allocate(pref(npz+1,2), dum1d(npz+1))
+
+   call fv_restart(Atm(mygrid)%domain, Atm, dt_atmos, seconds, days, cold_start, Atm(mygrid)%gridstruct%grid_type, mygrid)
+
+   fv_time = Time
+
+!----- initialize atmos_axes and fv_dynamics diagnostics
+       !I've had trouble getting this to work with multiple grids at a time; worth revisiting?
+   call fv_diag_init(Atm(mygrid:mygrid), Atm(mygrid)%atmos_axes, Time, npx, npy, npz, Atm(mygrid)%flagstruct%p_ref)
+
+   if (Atm(mygrid)%coarse_graining%write_coarse_diagnostics) then
+      call fv_coarse_diag_init(Atm, Time, Atm(mygrid)%atmos_axes(3), &
+           Atm(mygrid)%atmos_axes(4), Atm(mygrid)%coarse_graining)
+   endif
+   if (Atm(mygrid)%coarse_graining%write_coarse_restart_files) then
+       call fv_coarse_restart_init(Atm(mygrid)%npz, Atm(mygrid)%flagstruct%nt_prog, &
+            Atm(mygrid)%flagstruct%nt_phys, Atm(mygrid)%flagstruct%hydrostatic, &
+            Atm(mygrid)%flagstruct%hybrid_z, Atm(mygrid)%flagstruct%fv_land, &
+            Atm(mygrid)%coarse_graining%write_coarse_dgrid_vel_rst, &
+            Atm(mygrid)%coarse_graining%write_coarse_agrid_vel_rst, &
+            Atm(mygrid)%coarse_graining%restart)
+   endif
+#ifdef MARS_GCM
+      allocate(  p_std(Atm(mygrid)%npz+1) )
+      DO k= 1, Atm(mygrid)%npz + 1
+         p_std(k)= Atm(mygrid)%ak(k) + Atm(mygrid)%bk(k)*Atm(mygrid)%flagstruct%p_ref
+      ENDDO
+
+      call get_cubed_sphere_mars( Atm(mygrid) )
+
+      call mars_physics_init( Atm(mygrid)%npx, Atm(mygrid)%npy, Atm(mygrid)%npz,             &
+                 Atm(mygrid)%gridstruct%grid (isc:iec+1,jsc:jec+1,1),            &
+                 Atm(mygrid)%gridstruct%grid (isc:iec+1,jsc:jec+1,2),            &
+                 Atm(mygrid)%gridstruct%agrid(isc:iec  ,jsc:jec  ,1),            &
+                 Atm(mygrid)%gridstruct%agrid(isc:iec  ,jsc:jec  ,2),            &
+                 p_std, Atm(mygrid)%atmos_axes, Time, Atm(mygrid)%domain   )
+
+      deallocate( p_std )
+#endif
+!---------- reference profile -----------
+    ps1 = 101325.
+    ps2 =  81060.
+    pref(npz+1,1) = ps1
+    pref(npz+1,2) = ps2
+    call get_eta_level ( npz, ps1, pref(1,1), dum1d, Atm(mygrid)%ak, Atm(mygrid)%bk )
+    call get_eta_level ( npz, ps2, pref(1,2), dum1d, Atm(mygrid)%ak, Atm(mygrid)%bk )
+
+!  --- initialize clocks for dynamics, physics_down and physics_up
+   id_dynam     = mpp_clock_id ('FV dy-core',  flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_subgridz  = mpp_clock_id ('FV subgrid_z',flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_fv_diag   = mpp_clock_id ('FV Diag',     flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+
+
+!  --- initiate the start for a restarted regional forecast
+   if ( Atm(mygrid)%gridstruct%regional .and. Atm(mygrid)%flagstruct%warm_start ) then
+     call start_regional_restart(Atm(1),       &
+                                 isc, iec, jsc, jec, &
+                                 isd, ied, jsd, jed )
+   endif
+
+
+   !This appears to all be diagnostics through the end of this routine,
+   !and so for now we will only define for the coarsest grid
+
+!miz
+!---allocate id_tracer_*
+   allocate (id_tracerdt_dyn    (num_tracers))
+   if ( Atm(mygrid)%flagstruct%write_3d_diags) then
+      id_udt_dyn    =register_diag_field(mod_name,'udt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'udt_dyn',    'm/s/s', missing_value=mv)
+      id_vdt_dyn    =register_diag_field(mod_name,'vdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'vdt_dyn',    'm/s/s', missing_value=mv)
+      id_tdt_dyn    =register_diag_field(mod_name,'tdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'tdt_dyn',    'K/s', missing_value=mv)
+      id_qdt_dyn    =register_diag_field(mod_name,'qdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qdt_dyn',    'kg/kg/s', missing_value=mv)
+      id_qldt_dyn   =register_diag_field(mod_name,'qldt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qldt_dyn',   'kg/kg/s', missing_value=mv)
+      id_qidt_dyn   =register_diag_field(mod_name,'qidt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qidt_dyn',   'kg/kg/s', missing_value=mv)
+      id_qadt_dyn   =register_diag_field(mod_name,'qadt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qadt_dyn',   '1/s', missing_value=mv)
+
+      !---loop for tracers
+      do itrac = 1, num_tracers
+         call get_tracer_names (MODEL_ATMOS, itrac, name = tracer_name, units = tracer_units)
+         if (get_tracer_index(MODEL_ATMOS,tracer_name)>0) then
+            id_tracerdt_dyn(itrac) = register_diag_field(mod_name, TRIM(tracer_name)//'dt_dyn',  &
+                 Atm(mygrid)%atmos_axes(1:3),Time,                       &
+                 TRIM(tracer_name)//' total tendency from advection',    &
+                 TRIM(tracer_units)//'/s', missing_value = mv)
+         endif
+      enddo
+   endif
+   if (any(id_tracerdt_dyn(:)>0)) allocate(qtendyyf(isc:iec, jsc:jec,1:npz,num_tracers))
+   if ( id_tdt_dyn>0 )  allocate(ttend(isc:iec, jsc:jec, 1:npz))
+   if ( any((/ id_qdt_dyn, id_qldt_dyn, id_qidt_dyn, id_qadt_dyn /) > 0)  )  allocate(qtend(isc:iec, jsc:jec, 1:npz, 4))
+
+! could zero out diagnostics if tracer field not defined
+   if (sphum > size(qtend,4)) id_qdt_dyn = 0
+   if (liq_wat > size(qtend,4)) id_qldt_dyn = 0
+   if (ice_wat > size(qtend,4)) id_qidt_dyn = 0
+   if (cld_amt > size(qtend,4)) id_qadt_dyn = 0
+!miz
+
+!  --- initialize clocks for dynamics, physics_down and physics_up
+   id_dynam     = mpp_clock_id ('FV dy-core',  flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_subgridz  = mpp_clock_id ('FV subgrid_z',flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_fv_diag   = mpp_clock_id ('FV Diag',     flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+
+                    call timing_off('ATMOS_INIT')
+
+   call set_domain(Atm(mygrid)%domain)
+
+ end subroutine atmosphere_init
+
+
+!#######################################################################
+
+  subroutine atmosphere (Time)
+    type(time_type), intent(in) :: Time
+
+    real:: time_total
+    real:: tau_winds, tau_press, tau_temp
+	real:: rcp
+    integer :: n, sphum, p, nc
+    integer :: psc ! p_split counter
+    integer :: i, j, k, w_diff, nt_dyn, m
+
+#ifdef NUDGE_IC
+    tau_winds =  3600.
+    tau_press = -1.
+    tau_temp  = -1.
+#else
+    tau_winds = -1.
+    tau_press = -1.
+    tau_temp  = -1.
+#endif
+
+    fv_time = Time + Time_step_atmos
+    call get_time (fv_time, seconds,  days)
+
+    time_total = days*SECONDS_PER_DAY + seconds
+
+    call mpp_clock_begin(id_dynam)
+
+    n = mygrid
+    do psc=1,abs(p_split)
+
+       call set_domain(Atm(n)%domain)  ! needed for diagnostic output done in fv_dynamics
+
+                    call timing_on('fv_dynamics')
+!uc/vc only need be same on coarse grid? However BCs do need to be the same
+     call fv_dynamics(npx, npy, npz, nq, Atm(n)%ng, dt_atmos/real(abs(p_split)),&
+                      Atm(n)%flagstruct%consv_te, Atm(n)%flagstruct%fill,  &
+                      Atm(n)%flagstruct%reproduce_sum, kappa, cp_air, zvir,&
+                      Atm(n)%ptop, Atm(n)%ks, nq,                          &
+                      Atm(n)%flagstruct%n_split, Atm(n)%flagstruct%q_split,&
+                      Atm(n)%u, Atm(n)%v, Atm(n)%w, Atm(n)%delz,           &
+                      Atm(n)%flagstruct%hydrostatic,                       &
+                      Atm(n)%pt, Atm(n)%delp, Atm(n)%q, Atm(n)%ps,         &
+                      Atm(n)%pe, Atm(n)%pk, Atm(n)%peln,                   &
+                      Atm(n)%pkz, Atm(n)%phis, Atm(n)%q_con,               &
+                      Atm(n)%omga, Atm(n)%ua, Atm(n)%va, Atm(n)%uc,        &
+                      Atm(n)%vc, Atm(n)%ak, Atm(n)%bk, Atm(n)%mfx,         &
+                      Atm(n)%mfy, Atm(n)%cx, Atm(n)%cy, Atm(n)%ze0,        &
+                      Atm(n)%flagstruct%hybrid_z,                          &
+                      Atm(n)%gridstruct, Atm(n)%flagstruct,                &
+                      Atm(n)%neststruct, Atm(n)%idiag, Atm(n)%bd,          &
+                      Atm(n)%parent_grid, Atm(n)%domain, Atm(n)%inline_mp)
+
+     call timing_off('fv_dynamics')
+
+    if (ngrids > 1 .and. (psc < p_split .or. p_split < 0)) then
+       call mpp_sync()
+       call timing_on('TWOWAY_UPDATE')
+       call twoway_nesting(Atm, ngrids, grids_on_this_pe, zvir, fv_time, mygrid)
+       call timing_off('TWOWAY_UPDATE')
+    endif
+
+    end do !p_split
+    call mpp_clock_end (id_dynam)
+
+    u_dt = 0.
+    v_dt = 0.
+    t_dt = 0.
+    q_dt = 0.
+
+    w_diff = get_tracer_index (MODEL_ATMOS, 'w_diff' )
+    nt_dyn = ncnst-pnats   !nothing more than nq
+    if ( w_diff /= NO_TRACER ) then
+      nt_dyn = nt_dyn - 1
+    endif
+
+!--- adjust w and heat tendency for non-hydrostatic case
+    if ( .not.Atm(n)%flagstruct%hydrostatic .and. w_diff /= NO_TRACER ) then
+      rcp = 1. / cp_air
+!$OMP parallel do default (none) &
+!$OMP              shared (jsc, jec, isc, iec, n, w_diff, Atm, q_dt, t_dt, rcp, dt_atmos) &
+!$OMP             private (i, j, k)
+       do k=1, Atm(n)%npz
+         do j=jsc, jec
+           do i=isc, iec
+             Atm(n)%q(i,j,k,w_diff) = q_dt(i,j,k,w_diff) ! w tendency due to phys
+! Heating due to loss of KE (vertical diffusion of w)
+             t_dt(i,j,k) = t_dt(i,j,k) - q_dt(i,j,k,w_diff)*rcp*&
+                                     (Atm(n)%w(i,j,k)+0.5*dt_atmos*q_dt(i,j,k,w_diff))
+             Atm(n)%w(i,j,k) = Atm(n)%w(i,j,k) + dt_atmos*Atm(n)%q(i,j,k,w_diff)
+           enddo
+         enddo
+       enddo
+    endif
+
+
+       call mpp_clock_begin (id_phys)
+       call timing_on('mars_physics_update')
+       call mars_physics_update(Atm(n)%npx, Atm(n)%npy, Atm(n)%npz, isc, iec, jsc, jec, Atm(n)%ng, nt_dyn,   &
+                     u_dt, v_dt, t_dt, q_dt, Atm(n)%ua, Atm(n)%va, Atm(n)%pt, Atm(n)%q,   &
+                     Atm(n)%phis, Atm(n)%pe, Atm(n)%delp, Atm(n)%peln, dt_atmos, &
+                     Atm(n)%gridstruct%agrid, Atm(n)%ak, Atm(n)%bk,       &
+                     qratio, .false., .false., Atm(n)%flagstruct%p_ref, Time )
+
+       call timing_off('mars_physics_update')
+
+           call timing_on('FV_UPDATE_PHYS')
+       call fv_update_phys( dt_atmos, isc, iec, jsc, jec, isd, ied, jsd, jed, Atm(n)%ng, nt_dyn, &
+                         Atm(n)%u,  Atm(n)%v,   Atm(n)%w,  Atm(n)%delp, Atm(n)%pt,         &
+                         Atm(n)%q,  Atm(n)%qdiag,                                          &
+                         Atm(n)%ua, Atm(n)%va,  Atm(n)%ps, Atm(n)%pe,   Atm(n)%peln,       &
+                         Atm(n)%pk, Atm(n)%pkz, Atm(n)%ak, Atm(n)%bk,   Atm(n)%phis,       &
+                         Atm(n)%u_srf, Atm(n)%v_srf, Atm(n)%ts, Atm(n)%delz,               &
+                         Atm(n)%flagstruct%hydrostatic, u_dt, v_dt, t_dt,                  &
+                         .false., Time, Atm(n)%flagstruct%nudge, Atm(n)%gridstruct,    &
+                         Atm(n)%gridstruct%agrid(:,:,1), Atm(n)%gridstruct%agrid(:,:,2),   &
+                         Atm(n)%npx, Atm(n)%npy, Atm(n)%npz, Atm(n)%flagstruct,            &
+                         Atm(n)%neststruct, Atm(n)%bd, Atm(n)%domain, Atm(n)%ptop,         &
+                         Atm(n)%phys_diag, Atm(n)%nudge_diag, q_dt)
+          call timing_off('FV_UPDATE_PHYS')
+
+!-----------------------------------------
+! Adjust mass mixing ratio of all tracers:
+!!!! May NEED TO FIX THIS?!?!  Perhaps do this for prognostic tracers only, and
+!!!!      let the physics code figure out how to handle diagnostic tracers
+!-----------------------------------------
+     do m=1,nt_dyn
+       do k=1,npz
+         do j=jsc,jec
+             do i= isc,iec
+                Atm(n)%q(i,j,k,m) = Atm(n)%q(i,j,k,m) / qratio(i,j,k)
+             enddo
+          enddo
+       enddo
+     enddo
+
+     call nullify_domain()
+
+!--- nesting update after updating atmospheric variables with
+!--- physics tendencies
+    if (ngrids > 1 .and. p_split > 0) then
+       call timing_on('TWOWAY_UPDATE')
+       call twoway_nesting(Atm, ngrids, grids_on_this_pe, zvir, fv_time, mygrid)
+       call timing_off('TWOWAY_UPDATE')
+    endif
+       call mpp_clock_end (id_phys)
+
+
+  !---- diagnostics for FV dynamics -----
+
+       call nullify_domain()
+       call timing_on('FV_DIAG')
+       call fv_diag(Atm(n:n), zvir, fv_time, Atm(n)%flagstruct%print_freq)
+
+       call timing_off('FV_DIAG')
+
+ end subroutine atmosphere
+
+ subroutine atmosphere_domain ( fv_domain )
+   type(domain2d), intent(out) :: fv_domain
+!  returns the domain2d variable associated with the coupling grid
+!  note: coupling is done using the mass/temperature grid with no halos
+
+   fv_domain = Atm(mygrid)%domain_for_coupler
+
+ end subroutine atmosphere_domain
+
+ subroutine atmosphere_end
+
+   integer n
+
+    call get_time (fv_time, seconds,  days)
+
+#if defined(MARS_GCM) || defined(VENUS_GCM) || defined(STRAT_GCM)
+    do n=1,ngrids
+      call set_domain ( Atm(n)%domain )
+    !          Need to write physics restart files
+      if( grids_on_this_pe(N) )  call mars_physics_end( days )
+
+      call nullify_domain ( )
+    enddo
+#else
+    do n=1,ngrids
+       if ( Atm(n)%flagstruct%moist_phys .and. Atm(n)%flagstruct%nwat==6 .and. grids_on_this_pe(N)) call lin_cld_microphys_end
+    enddo
+#endif
+#ifndef SINGLE_TILE
+    call fv_end(Atm, mygrid)
+    deallocate(Atm)
+#endif
+   deallocate( u_dt, v_dt, t_dt, qv_dt, q_dt, pref, dum1d )
+   deallocate( qratio)
+
+
+ end subroutine atmosphere_end
+
+#else
+
+ subroutine atmosphere_init (Time_init, Time, Time_step, Surf_diff, Grid_box)
+   type (time_type),      intent(in)    :: Time_init, Time, Time_step
+   type(surf_diff_type),  intent(inout) :: Surf_diff
+   type(grid_box_type),   intent(inout) :: Grid_box
+
+!--- local variables ---
+   integer :: i, n
+   integer :: itrac
+   logical :: do_atmos_nudge
+   character(len=32) :: tracer_name, tracer_units
+   real :: ps1, ps2
+
+   integer :: nlunit = 9999
+   character (len = 64) :: fn_nml = 'input.nml'
+
+   !For regional
+   a_step = 0
+   current_time_in_seconds = time_type_to_real( Time - Time_init )
+   if (mpp_pe() == 0) write(0,"('atmosphere_init: current_time_seconds = ',f9.1)")current_time_in_seconds
+
+                    call timing_on('ATMOS_INIT')
+   allocate(pelist(mpp_npes()))
+   call mpp_get_current_pelist(pelist)
+
+   call get_number_tracers(MODEL_ATMOS, num_prog= num_tracers)
+
+   zvir = rvgas/rdgas - 1.
+
+!---- compute physics/atmos time step in seconds ----
+
+   Time_step_atmos = Time_step
+   call get_time (Time_step_atmos, sec)
+   dt_atmos = real(sec)
+
+!----- initialize FV dynamical core -----
+   !NOTE do we still need the second file_exist call?
+   cold_start = (.not.file_exist('INPUT/fv_core.res.nc') .and. .not.file_exist('INPUT/fv_core.res.tile1.nc'))
+
+   call fv_control_init( Atm, dt_atmos, mygrid, grids_on_this_pe, p_split )  ! allocates Atm components; sets mygrid
+
+   if (Atm(mygrid)%coarse_graining%write_coarse_restart_files .or. &
+       Atm(mygrid)%coarse_graining%write_coarse_diagnostics) then
+      call coarse_graining_init(Atm(mygrid)%flagstruct%npx, Atm(mygrid)%npz, &
+           Atm(mygrid)%layout, Atm(mygrid)%bd%is, Atm(mygrid)%bd%ie, &
+           Atm(mygrid)%bd%js, Atm(mygrid)%bd%je, Atm(mygrid)%coarse_graining%factor, &
+           Atm(mygrid)%coarse_graining%nx_coarse, &
+           Atm(mygrid)%coarse_graining%strategy, &
+           Atm(mygrid)%coarse_graining%domain)
+   endif
+
+   Atm(mygrid)%Time_init = Time_init
+
+!----- write version and namelist to log file -----
+   call write_version_number ( mod_name, version )
+
+!-----------------------------------
+
+   npx   = Atm(mygrid)%npx
+   npy   = Atm(mygrid)%npy
+   npz   = Atm(mygrid)%npz
+   ncnst = Atm(mygrid)%ncnst
+   pnats = Atm(mygrid)%flagstruct%pnats
+
+   isc = Atm(mygrid)%bd%isc
+   iec = Atm(mygrid)%bd%iec
+   jsc = Atm(mygrid)%bd%jsc
+   jec = Atm(mygrid)%bd%jec
+
+   isd = isc - Atm(mygrid)%bd%ng
+   ied = iec + Atm(mygrid)%bd%ng
+   jsd = jsc - Atm(mygrid)%bd%ng
+   jed = jec + Atm(mygrid)%bd%ng
+
+   nq = ncnst-pnats
+   sphum   = get_tracer_index (MODEL_ATMOS, 'sphum' )
+   liq_wat = get_tracer_index (MODEL_ATMOS, 'liq_wat' )
+   ice_wat = get_tracer_index (MODEL_ATMOS, 'ice_wat' )
+   rainwat = get_tracer_index (MODEL_ATMOS, 'rainwat' )
+   snowwat = get_tracer_index (MODEL_ATMOS, 'snowwat' )
+   graupel = get_tracer_index (MODEL_ATMOS, 'graupel' )
+   cld_amt = get_tracer_index (MODEL_ATMOS, 'cld_amt' )
+
+   if (max(sphum,liq_wat,ice_wat,rainwat,snowwat,graupel) > Atm(mygrid)%flagstruct%nwat) then
+      call mpp_error (FATAL,' atmosphere_init: condensate species are not first in the list of &
+                            &tracers defined in the field_table')
+   endif
+
+   ! Allocate grid variables to be used to calculate gradient in 2nd order flux exchange
+   ! This data is only needed for the COARSEST grid.
+   !call switch_current_Atm(Atm(mygrid))
+   call set_domain(Atm(mygrid)%domain)
+
+   allocate(Grid_box%dx    (   isc:iec  , jsc:jec+1))
+   allocate(Grid_box%dy    (   isc:iec+1, jsc:jec  ))
+   allocate(Grid_box%area  (   isc:iec  , jsc:jec  ))
+   allocate(Grid_box%edge_w(              jsc:jec+1))
+   allocate(Grid_box%edge_e(              jsc:jec+1))
+   allocate(Grid_box%edge_s(   isc:iec+1           ))
+   allocate(Grid_box%edge_n(   isc:iec+1           ))
+   allocate(Grid_box%en1   (3, isc:iec  , jsc:jec+1))
+   allocate(Grid_box%en2   (3, isc:iec+1, jsc:jec  ))
+   allocate(Grid_box%vlon  (3, isc:iec  , jsc:jec  ))
+   allocate(Grid_box%vlat  (3, isc:iec  , jsc:jec  ))
+   Grid_box%dx    (   isc:iec  , jsc:jec+1) = Atm(mygrid)%gridstruct%dx    (   isc:iec,   jsc:jec+1)
+   Grid_box%dy    (   isc:iec+1, jsc:jec  ) = Atm(mygrid)%gridstruct%dy    (   isc:iec+1, jsc:jec  )
+   Grid_box%area  (   isc:iec  , jsc:jec  ) = Atm(mygrid)%gridstruct%area  (   isc:iec  , jsc:jec  )
+   Grid_box%edge_w(              jsc:jec+1) = Atm(mygrid)%gridstruct%edge_w(              jsc:jec+1)
+   Grid_box%edge_e(              jsc:jec+1) = Atm(mygrid)%gridstruct%edge_e(              jsc:jec+1)
+   Grid_box%edge_s(   isc:iec+1           ) = Atm(mygrid)%gridstruct%edge_s(   isc:iec+1)
+   Grid_box%edge_n(   isc:iec+1           ) = Atm(mygrid)%gridstruct%edge_n(   isc:iec+1)
+   Grid_box%en1   (:, isc:iec  , jsc:jec+1) = Atm(mygrid)%gridstruct%en1   (:, isc:iec  , jsc:jec+1)
+   Grid_box%en2   (:, isc:iec+1, jsc:jec  ) = Atm(mygrid)%gridstruct%en2   (:, isc:iec+1, jsc:jec  )
+   do i = 1,3
+     Grid_box%vlon  (i, isc:iec  , jsc:jec  ) = Atm(mygrid)%gridstruct%vlon  (isc:iec ,  jsc:jec, i )
+     Grid_box%vlat  (i, isc:iec  , jsc:jec  ) = Atm(mygrid)%gridstruct%vlat  (isc:iec ,  jsc:jec, i )
+   enddo
+
+!----- allocate and zero out the dynamics (and accumulated) tendencies
+   allocate( u_dt(isd:ied,jsd:jed,npz), &
+             v_dt(isd:ied,jsd:jed,npz), &
+             t_dt(isc:iec,jsc:jec,npz), &
+             qv_dt(isc:iec,jsc:jec,npz), &
+             q_dt(isc:iec,jsc:jec,npz,nq) )
+!--- allocate pref
+   allocate(pref(npz+1,2), dum1d(npz+1))
+
+   call fv_restart(Atm(mygrid)%domain, Atm, dt_atmos, seconds, days, cold_start, Atm(mygrid)%gridstruct%grid_type, mygrid)
+
+   fv_time = Time
+
+!----- initialize atmos_axes and fv_dynamics diagnostics
+       !I've had trouble getting this to work with multiple grids at a time; worth revisiting?
+   call fv_diag_init(Atm(mygrid:mygrid), Atm(mygrid)%atmos_axes, Time, npx, npy, npz, Atm(mygrid)%flagstruct%p_ref)
+
+   if (Atm(mygrid)%coarse_graining%write_coarse_diagnostics) then
+      call fv_coarse_diag_init(Atm, Time, Atm(mygrid)%atmos_axes(3), &
+           Atm(mygrid)%atmos_axes(4), Atm(mygrid)%coarse_graining)
+   endif
+   if (Atm(mygrid)%coarse_graining%write_coarse_restart_files) then
+      call fv_coarse_restart_init(Atm(mygrid)%npz, Atm(mygrid)%flagstruct%nt_prog, &
+           Atm(mygrid)%flagstruct%nt_phys, Atm(mygrid)%flagstruct%hydrostatic, &
+           Atm(mygrid)%flagstruct%hybrid_z, Atm(mygrid)%flagstruct%fv_land, &
+           Atm(mygrid)%coarse_graining%write_coarse_dgrid_vel_rst, &
+           Atm(mygrid)%coarse_graining%write_coarse_agrid_vel_rst, &
+           Atm(mygrid)%coarse_graining%restart)
+   endif
+
+!---------- reference profile -----------
+    ps1 = 101325.
+    ps2 =  81060.
+    pref(npz+1,1) = ps1
+    pref(npz+1,2) = ps2
+    call get_eta_level ( npz, ps1, pref(1,1), dum1d, Atm(mygrid)%ak, Atm(mygrid)%bk )
+    call get_eta_level ( npz, ps2, pref(1,2), dum1d, Atm(mygrid)%ak, Atm(mygrid)%bk )
+
+!  --- initialize clocks for dynamics, physics_down and physics_up
+   id_dynam     = mpp_clock_id ('FV dy-core',  flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_subgridz  = mpp_clock_id ('FV subgrid_z',flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_fv_diag   = mpp_clock_id ('FV Diag',     flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+!---- initialize cmip diagnostic output ----
+   call atmos_cmip_diag_init   ( Atm(mygrid)%ak, Atm(mygrid)%bk, pref(1,1), Atm(mygrid)%atmos_axes, Time )
+   call atmos_global_diag_init ( Atm(mygrid)%atmos_axes, Atm(mygrid)%gridstruct%area(isc:iec,jsc:jec) )
+   call fv_cmip_diag_init      ( Atm(mygrid:mygrid), Atm(mygrid)%atmos_axes, Time )
+
+!--- initialize nudging module ---
+#if defined (ATMOS_NUDGE)
+    call atmos_nudge_init ( Time, Atm(mygrid)%atmos_axes(1:3), flag=do_atmos_nudge )
+    if ( do_atmos_nudge .and. Atm(mygrid)%flagstruct%nudge ) then
+         call mpp_error(NOTE, 'Code compiled with atmospheric nudging, but fv_core_nml nudge is also set to .true.')
+    elseif ( do_atmos_nudge) then
+         call mpp_error(NOTE, 'Code compiled with and using atmospheric nudging')
+    endif
+    Atm(mygrid)%flagstruct%nudge = do_atmos_nudge
+#elif defined (CLIMATE_NUDGE)
+    call fv_climate_nudge_init ( Time, Atm(mygrid)%atmos_axes(1:3), flag=do_atmos_nudge )
+    if ( do_atmos_nudge .and. Atm(mygrid)%flagstruct%nudge ) then
+         call mpp_error(NOTE, 'Code compiled with climate nudging, but fv_core_nml nudge is also set to .true.')
+    elseif ( do_atmos_nudge ) then
+         call mpp_error(NOTE, 'Code compiled with and using climate nudging')
+    endif
+    Atm(mygrid)%flagstruct%nudge = do_atmos_nudge
+#elif defined (ADA_NUDGE)
+    if ( Atm(mygrid)%flagstruct%nudge ) then
+        call fv_ada_nudge_init( Time, Atm(mygrid)%atmos_axes, npz, zvir, Atm(mygrid)%ak, Atm(mygrid)%bk, &
+           Atm(mygrid)%ts, Atm(mygrid)%phis, Atm(mygrid)%gridstruct, Atm(mygrid)%ks, Atm(mygrid)%npx,    &
+           Atm(mygrid)%neststruct, Atm(mygrid)%bd, Atm(mygrid)%domain)
+        call mpp_error(NOTE, 'ADA nudging is active')
+     endif
+#else
+   !Only do nudging on coarse grid for now
+   if ( Atm(mygrid)%flagstruct%nudge ) then
+      call fv_nwp_nudge_init( Time, Atm(mygrid)%atmos_axes, npz, zvir, Atm(mygrid)%ak, Atm(mygrid)%bk, &
+           Atm(mygrid)%ts, Atm(mygrid)%phis, Atm(mygrid)%gridstruct, Atm(mygrid)%ks, Atm(mygrid)%npx,  &
+           Atm(mygrid)%neststruct, Atm(mygrid)%bd)
+        call mpp_error(NOTE, 'NWP nudging is active')
+   endif
+#endif
+
+!  --- initiate the start for a restarted regional forecast
+   if ( Atm(mygrid)%gridstruct%regional .and. Atm(mygrid)%flagstruct%warm_start ) then
+     call start_regional_restart(Atm(1),       &
+                                 isc, iec, jsc, jec, &
+                                 isd, ied, jsd, jed )
+   endif
+
+! This call needs to be separate from the register nudging restarts after initialization
+   call fv_io_register_nudge_restart ( Atm )
+
+   if ( Atm(mygrid)%flagstruct%na_init>0 ) then
+      call nullify_domain ( )
+      if ( .not. Atm(mygrid)%flagstruct%hydrostatic ) then
+           call prt_maxmin('Before adi: W', Atm(mygrid)%w, isc, iec, jsc, jec, Atm(mygrid)%ng, npz, 1.)
+      endif
+      call adiabatic_init(zvir,Atm(mygrid)%flagstruct%nudge_dz)
+      if ( .not. Atm(mygrid)%flagstruct%hydrostatic ) then
+           call prt_maxmin('After adi: W', Atm(mygrid)%w, isc, iec, jsc, jec, Atm(mygrid)%ng, npz, 1.)
+! Not nested?
+           call prt_height('na_ini Z500', isc,iec, jsc,jec, 3, npz, 500.E2, Atm(mygrid)%phis, Atm(mygrid)%delz,    &
+                Atm(mygrid)%peln, Atm(mygrid)%gridstruct%area_64(isc:iec,jsc:jec), Atm(mygrid)%gridstruct%agrid_64(isc:iec,jsc:jec,2))
+      endif
+   else
+      call mpp_error(NOTE,'No adiabatic initialization correction in use')
+   endif
+
+   !This appears to all be diagnostics through the end of this routine,
+   !and so for now we will only define for the coarsest grid
+
+!miz
+!---allocate id_tracer_*
+   allocate (id_tracerdt_dyn    (num_tracers))
+   if ( Atm(mygrid)%flagstruct%write_3d_diags) then
+      id_udt_dyn    =register_diag_field(mod_name,'udt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'udt_dyn',    'm/s/s', missing_value=mv)
+      id_vdt_dyn    =register_diag_field(mod_name,'vdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'vdt_dyn',    'm/s/s', missing_value=mv)
+      id_tdt_dyn    =register_diag_field(mod_name,'tdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'tdt_dyn',    'K/s', missing_value=mv)
+      id_qdt_dyn    =register_diag_field(mod_name,'qdt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qdt_dyn',    'kg/kg/s', missing_value=mv)
+      id_qldt_dyn   =register_diag_field(mod_name,'qldt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qldt_dyn',   'kg/kg/s', missing_value=mv)
+      id_qidt_dyn   =register_diag_field(mod_name,'qidt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qidt_dyn',   'kg/kg/s', missing_value=mv)
+      id_qadt_dyn   =register_diag_field(mod_name,'qadt_dyn', Atm(mygrid)%atmos_axes(1:3),  &
+           Time,'qadt_dyn',   '1/s', missing_value=mv)
+      !--- register cmip tendency fields ---
+      ID_tnta = register_cmip_diag_field_3d (mod_name, 'tnta', Time, &
+           'Tendency of Air Temperature due to Advection', 'K s-1', &
+           standard_name='tendency_of_air_temperature_due_to_advection')
+      ID_tnhusa = register_cmip_diag_field_3d (mod_name, 'tnhusa', Time, &
+           'Tendency of Specific Humidity due to Advection', 's-1', &
+           standard_name='tendency_of_specific_humidity_due_to_advection')
+      ID_tnt = register_cmip_diag_field_3d (mod_name, 'tnt', Time, &
+           'Tendency of Air Temperature', 'K s-1', &
+           standard_name='tendency_of_air_temperature')
+      ID_tnhus = register_cmip_diag_field_3d (mod_name, 'tnhus', Time, &
+           'Tendency of Specific Humidity', 's-1', &
+           standard_name='tendency_of_specific_humidity')
+
+      !---loop for tracers
+      do itrac = 1, num_tracers
+         call get_tracer_names (MODEL_ATMOS, itrac, name = tracer_name, units = tracer_units)
+         if (get_tracer_index(MODEL_ATMOS,tracer_name)>0) then
+            id_tracerdt_dyn(itrac) = register_diag_field(mod_name, TRIM(tracer_name)//'dt_dyn',  &
+                 Atm(mygrid)%atmos_axes(1:3),Time,                       &
+                 TRIM(tracer_name)//' total tendency from advection',    &
+                 TRIM(tracer_units)//'/s', missing_value = mv)
+         endif
+      enddo
+   endif
+   if (any(id_tracerdt_dyn(:)>0)) allocate(qtendyyf(isc:iec, jsc:jec,1:npz,num_tracers))
+   if ( id_tdt_dyn>0 .or. query_cmip_diag_id(ID_tnta) .or. query_cmip_diag_id(ID_tnt) ) &
+                                                      allocate(ttend(isc:iec, jsc:jec, 1:npz))
+   if ( any((/ id_qdt_dyn, id_qldt_dyn, id_qidt_dyn, id_qadt_dyn /) > 0) .or. &
+        query_cmip_diag_id(ID_tnhusa) .or. query_cmip_diag_id(ID_tnhus) )  allocate(qtend(isc:iec, jsc:jec, 1:npz, 4))
+
+! could zero out diagnostics if tracer field not defined
+   if (sphum > size(qtend,4)) id_qdt_dyn = 0
+   if (liq_wat > size(qtend,4)) id_qldt_dyn = 0
+   if (ice_wat > size(qtend,4)) id_qidt_dyn = 0
+   if (cld_amt > size(qtend,4)) id_qadt_dyn = 0
+!miz
+
+!  --- initialize clocks for dynamics, physics_down and physics_up
+   id_dynam     = mpp_clock_id ('FV dy-core',  flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_subgridz  = mpp_clock_id ('FV subgrid_z',flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+   id_fv_diag   = mpp_clock_id ('FV Diag',     flags = clock_flag_default, grain=CLOCK_SUBCOMPONENT )
+
+                    call timing_off('ATMOS_INIT')
+
+   call set_domain(Atm(mygrid)%domain)
+
+ end subroutine atmosphere_init
+
+
+ subroutine p_adi(km, ng, ifirst, ilast, jfirst, jlast, ptop,   &
+                  delp, pt, ps, pe, peln, pk, pkz, hydrostatic)
+! Given (ptop, delp) computes (ps, pk, pe, peln, pkz)
+! Input:
+   integer,  intent(in):: km, ng
+   integer,  intent(in):: ifirst, ilast            ! Longitude strip
+   integer,  intent(in):: jfirst, jlast            ! Latitude strip
+   logical, intent(in)::  hydrostatic
+   real, intent(in):: ptop
+   real, intent(in)::   pt(ifirst-ng:ilast+ng,jfirst-ng:jlast+ng, km)
+   real, intent(in):: delp(ifirst-ng:ilast+ng,jfirst-ng:jlast+ng, km)
+! Output:
+   real, intent(out) ::   ps(ifirst-ng:ilast+ng, jfirst-ng:jlast+ng)
+   real, intent(out) ::   pk(ifirst:ilast, jfirst:jlast, km+1)
+   real, intent(out) ::   pe(ifirst-1:ilast+1,km+1,jfirst-1:jlast+1) ! Ghosted Edge pressure
+   real, intent(out) :: peln(ifirst:ilast, km+1, jfirst:jlast)    ! Edge pressure
+   real, intent(out) ::  pkz(ifirst:ilast, jfirst:jlast, km)
+! Local
+   real pek
+   integer i, j, k
+
+   pek = ptop ** kappa
+!$OMP parallel do default (none) &
+!$OMP              shared (ifirst,ilast,jfirst,jlast,km,ptop,pek,pe,pk, &
+!$OMP                      ps,delp,peln,hydrostatic,pkz) &
+!$OMP             private (j, i, k)
+   do j=jfirst,jlast
+      do i=ifirst,ilast
+         pe(i,1,j) = ptop
+         pk(i,j,1) = pek
+      enddo
+
+      do k=2,km+1
+         do i=ifirst,ilast
+            pe(i,k,j) = pe(i,k-1,j) + delp(i,j,k-1)
+            peln(i,k,j) = log(pe(i,k,j))
+            pk(i,j,k) = exp( kappa*peln(i,k,j) )
+         enddo
+      enddo
+
+      do i=ifirst,ilast
+         ps(i,j) = pe(i,km+1,j)
+      enddo
+
+      if ( hydrostatic ) then
+         do k=1,km
+            do i=ifirst,ilast
+               pkz(i,j,k) = (pk(i,j,k+1)-pk(i,j,k))/(kappa*(peln(i,k+1,j)-peln(i,k,j)))
+            enddo
+         enddo
+      endif
+   enddo
+
+ end subroutine p_adi
+
+
+ subroutine atmosphere_dynamics ( Time, Surf_diff )
+   type(time_type),intent(in) :: Time
+   integer :: itrac, n, psc
+   integer :: k, w_diff, nt_dyn
+   type(surf_diff_type), intent(inout):: Surf_diff
+   logical :: used
+   type(time_type) :: atmos_time
+   integer :: atmos_time_step
+   real :: rdt
+!---- Call FV dynamics -----
+
+   call mpp_clock_begin (id_dynam)
+
+   Surf_diff%ddp_dyn(:,:,:) = Atm(mygrid)%delp(isc:iec, jsc:jec, :)
+   Surf_diff%tdt_dyn(:,:,:) = Atm(mygrid)%pt(isc:iec, jsc:jec, :)
+   Surf_diff%qdt_dyn(:,:,:) = Atm(mygrid)%q (isc:iec, jsc:jec, :, sphum) + &
+                              Atm(mygrid)%q (isc:iec, jsc:jec, :, liq_wat) + &
+                              Atm(mygrid)%q (isc:iec, jsc:jec, :, ice_wat)
+
+!miz
+   if ( id_tdt_dyn>0 .or. query_cmip_diag_id(ID_tnta) ) ttend(:, :, :) = Atm(mygrid)%pt(isc:iec, jsc:jec, :)
+   if ( any((/ id_qdt_dyn, id_qldt_dyn, id_qidt_dyn, id_qadt_dyn /) > 0) .or. &
+        query_cmip_diag_id(ID_tnhusa) ) qtend(:, :, :, 1:4) = Atm(mygrid)%q (isc:iec, jsc:jec, :, 1:4)
+!miz
+   do itrac = 1, num_tracers
+     if (id_tracerdt_dyn (itrac) >0 ) &
+            qtendyyf(:,:,:,itrac) = Atm(mygrid)%q(isc:iec,jsc:jec,:,itrac)
+   enddo
+
+   n = mygrid
+   a_step = a_step + 1
+!
+!*** If this is a regional run then read in the next boundary data when it is time.
+!
+   if(Atm(n)%flagstruct%regional)then
+
+     call read_new_bc_data(Atm(n), Time, Time_step_atmos, p_split, &
+                           isd, ied, jsd, jed )
+   endif
+   do psc=1,abs(p_split)
+      p_step = psc
+                    call timing_on('fv_dynamics')
+!uc/vc only need be same on coarse grid? However BCs do need to be the same
+     call fv_dynamics(npx, npy, npz, nq, Atm(n)%ng, dt_atmos/real(abs(p_split)),&
+                      Atm(n)%flagstruct%consv_te, Atm(n)%flagstruct%fill,  &
+                      Atm(n)%flagstruct%reproduce_sum, kappa, cp_air, zvir,&
+                      Atm(n)%ptop, Atm(n)%ks, nq,                          &
+                      Atm(n)%flagstruct%n_split, Atm(n)%flagstruct%q_split,&
+                      Atm(n)%u, Atm(n)%v, Atm(n)%w, Atm(n)%delz,           &
+                      Atm(n)%flagstruct%hydrostatic,                       &
+                      Atm(n)%pt, Atm(n)%delp, Atm(n)%q, Atm(n)%ps,         &
+                      Atm(n)%pe, Atm(n)%pk, Atm(n)%peln,                   &
+                      Atm(n)%pkz, Atm(n)%phis, Atm(n)%q_con,               &
+                      Atm(n)%omga, Atm(n)%ua, Atm(n)%va, Atm(n)%uc,        &
+                      Atm(n)%vc, Atm(n)%ak, Atm(n)%bk, Atm(n)%mfx,         &
+                      Atm(n)%mfy, Atm(n)%cx, Atm(n)%cy, Atm(n)%ze0,        &
+                      Atm(n)%flagstruct%hybrid_z,                          &
+                      Atm(n)%gridstruct, Atm(n)%flagstruct,                &
+                      Atm(n)%neststruct, Atm(n)%idiag, Atm(n)%bd,          &
+                      Atm(n)%parent_grid, Atm(n)%domain, Atm(n)%inline_mp)
+
+     call timing_off('fv_dynamics')
+
+    if (ngrids > 1 .and. (psc < p_split .or. p_split < 0)) then
+       call mpp_sync()
+       call timing_on('TWOWAY_UPDATE')
+       call twoway_nesting(Atm, ngrids, grids_on_this_pe, zvir, fv_time, mygrid)
+       call timing_off('TWOWAY_UPDATE')
+    endif
+
+    end do !p_split
+    call mpp_clock_end (id_dynam)
+
+   Surf_diff%ddp_dyn(:,:,:) =(Atm(mygrid)%delp(isc:iec,jsc:jec,:)-Surf_diff%ddp_dyn(:,:,:))/dt_atmos
+   Surf_diff%tdt_dyn(:,:,:) =(Atm(mygrid)%pt(isc:iec,jsc:jec,:)  -Surf_diff%tdt_dyn(:,:,:))/dt_atmos
+   Surf_diff%qdt_dyn(:,:,:) =(Atm(mygrid)%q (isc:iec,jsc:jec,:,sphum) + &
+                              Atm(mygrid)%q (isc:iec,jsc:jec,:,liq_wat) + &
+                              Atm(mygrid)%q (isc:iec,jsc:jec,:,ice_wat) - Surf_diff%qdt_dyn(:,:,:))/dt_atmos
+
+!miz
+   if (id_udt_dyn>0)  used = send_data( id_udt_dyn, 2.0/dt_atmos*Atm(mygrid)%ua(isc:iec,jsc:jec,:), Time)
+   if (id_vdt_dyn>0)  used = send_data( id_vdt_dyn, 2.0/dt_atmos*Atm(mygrid)%va(isc:iec,jsc:jec,:), Time)
+   if (id_tdt_dyn > 0) used = send_data( id_tdt_dyn, (Atm(mygrid)%pt(isc:iec,jsc:jec,:)-ttend(:,:,:))/dt_atmos, Time)
+   if (query_cmip_diag_id(ID_tnta)) &
+                 used = send_cmip_data_3d ( ID_tnta, (Atm(mygrid)%pt(isc:iec,jsc:jec,:)-ttend(:,:,:))/dt_atmos, Time)
+
+   if (id_qdt_dyn  > 0) used = send_data( id_qdt_dyn , (Atm(mygrid)%q(isc:iec,jsc:jec,:,sphum)-qtend(:,:,:,sphum))/dt_atmos, Time)
+   if (id_qldt_dyn > 0) used = send_data( id_qldt_dyn, (Atm(mygrid)%q(isc:iec,jsc:jec,:,liq_wat)-qtend(:,:,:,liq_wat))/dt_atmos, Time)
+   if (id_qidt_dyn > 0) used = send_data( id_qidt_dyn, (Atm(mygrid)%q(isc:iec,jsc:jec,:,ice_wat)-qtend(:,:,:,ice_wat))/dt_atmos, Time)
+   if (id_qadt_dyn > 0) used = send_data( id_qadt_dyn, (Atm(mygrid)%q(isc:iec,jsc:jec,:,cld_amt)-qtend(:,:,:,cld_amt))/dt_atmos, Time)
+   if (query_cmip_diag_id(ID_tnhusa)) &
+                  used = send_cmip_data_3d (ID_tnhusa, (Atm(mygrid)%q(isc:iec,jsc:jec,:,sphum)-qtend(:,:,:,sphum))/dt_atmos, Time)
+!miz
+
+   do itrac = 1, num_tracers
+     if(id_tracerdt_dyn(itrac)>0) then
+       qtendyyf(:,:,:,itrac) = (Atm(mygrid)%q (isc:iec, jsc:jec, :,itrac)-  &
+                                qtendyyf(:,:,:,itrac))/dt_atmos
+       used = send_data(id_tracerdt_dyn(itrac), qtendyyf(:,:,:,itrac), Time)
+     endif
+   enddo
+
+!-----------------------------------------------------
+!--- COMPUTE SUBGRID Z
+!-----------------------------------------------------
+!--- zero out tendencies
+    call mpp_clock_begin (id_subgridz)
+    u_dt(:,:,:)   = 0. ! These are updated by fv_subgrid_z
+    v_dt(:,:,:)   = 0.
+! t_dt is used for two different purposes:
+!    1 - to calculate the diagnostic temperature tendency from fv_subgrid_z
+!    2 - as an accumulator for the IAU increment and physics tendency
+! because of this, it will need to be zeroed out after the diagnostic is calculated
+    t_dt(:,:,:)   = Atm(n)%pt(isc:iec,jsc:jec,:)
+    qv_dt(:,:,:)  = Atm(n)%q (isc:iec,jsc:jec,:,sphum)
+    q_dt(:,:,:,:) = 0.
+
+    rdt = 1./dt_atmos
+
+    w_diff = get_tracer_index (MODEL_ATMOS, 'w_diff' )
+    if ( Atm(n)%flagstruct%fv_sg_adj > 0 ) then
+      nt_dyn = nq
+      if ( w_diff /= NO_TRACER ) then
+        nt_dyn = nq - 1
+      endif
+      call fv_subgrid_z(isd, ied, jsd, jed, isc, iec, jsc, jec, Atm(n)%npz, &
+                        nt_dyn, dt_atmos, Atm(n)%flagstruct%fv_sg_adj,      &
+                        Atm(n)%flagstruct%nwat, Atm(n)%delp, Atm(n)%pe,     &
+                        Atm(n)%peln, Atm(n)%pkz, Atm(n)%pt, Atm(n)%q,       &
+                        Atm(n)%ua, Atm(n)%va, Atm(n)%flagstruct%hydrostatic,&
+                        Atm(n)%w, Atm(n)%delz, u_dt, v_dt, t_dt, q_dt,      &
+                        Atm(n)%flagstruct%n_sponge)
+    endif
+
+#ifdef USE_Q_DT
+    if ( .not. Atm(n)%flagstruct%hydrostatic .and. w_diff /= NO_TRACER ) then
+!$OMP parallel do default (none) &
+!$OMP              shared (isc, iec, jsc, jec, w_diff, n, Atm, q_dt) &
+!$OMP             private (k)
+       do k=1, Atm(n)%npz
+          Atm(n)%q(isc:iec,jsc:jec,k,w_diff) = Atm(n)%w(isc:iec,jsc:jec,k) + w0_big
+          q_dt(:,:,k,w_diff) = 0.
+        enddo
+    endif
+#endif
+
+    if (Atm(1)%idiag%id_u_dt_sg > 0) then
+       used = send_data(Atm(1)%idiag%id_u_dt_sg, u_dt(isc:iec,jsc:jec,:), fv_time)
+    end if
+    if (Atm(1)%idiag%id_v_dt_sg > 0) then
+       used = send_data(Atm(1)%idiag%id_v_dt_sg, v_dt(isc:iec,jsc:jec,:), fv_time)
+    end if
+    if (Atm(1)%idiag%id_t_dt_sg > 0) then
+       t_dt(:,:,:) = rdt*(Atm(1)%pt(isc:iec,jsc:jec,:) - t_dt(:,:,:))
+       used = send_data(Atm(1)%idiag%id_t_dt_sg, t_dt, fv_time)
+    end if
+    if (Atm(1)%idiag%id_qv_dt_sg > 0) then
+       qv_dt(:,:,:) = rdt*(Atm(1)%q(isc:iec,jsc:jec,:,sphum) - qv_dt(:,:,:))
+       used = send_data(Atm(1)%idiag%id_qv_dt_sg, qv_dt, fv_time)
+    end if
+
+! zero out t_dt for use as an accumulator
+    t_dt = 0.
+
+   call mpp_clock_end (id_subgridz)
+
+ end subroutine atmosphere_dynamics
+
+
+ subroutine atmosphere_end (Time, Grid_box )!rab, Radiation, Physics)
+   type (time_type),      intent(in)    :: Time
+   type(grid_box_type),   intent(inout) :: Grid_box
+!rab   type (radiation_type), intent(inout) :: Radiation
+!rab   type (physics_type),   intent(inout) :: Physics
+
+  ! initialize domains for writing global physics data
+   call set_domain ( Atm(mygrid)%domain )
+
+
+!--- end nudging module ---
+#if defined (ATMOS_NUDGE)
+   if ( Atm(mygrid)%flagstruct%nudge ) call atmos_nudge_end
+#elif defined (CLIMATE_NUDGE)
+   if ( Atm(mygrid)%flagstruct%nudge ) call fv_climate_nudge_end
+#elif defined (ADA_NUDGE)
+   if ( Atm(mygrid)%flagstruct%nudge ) call fv_ada_nudge_end
+#else
+   if ( Atm(mygrid)%flagstruct%nudge ) call fv_nwp_nudge_end
+#endif
+
+   if (Atm(mygrid)%flagstruct%do_inline_mp) then
+     call gfdl_mp_end ( )
+   endif
+
+      call timing_on('FV_DIAG')
+   call atmos_global_diag_end
+   call fv_cmip_diag_end
+      call timing_off('FV_DIAG')
+   call nullify_domain ( )
+   call fv_end(Atm, mygrid)
+   deallocate (Atm)
+
+   deallocate( u_dt, v_dt, t_dt, qv_dt, q_dt, pref, dum1d )
+
+ end subroutine atmosphere_end
+
+
+
+  !#######################################################################
+  ! <SUBROUTINE NAME="atmosphere_restart">
+  ! <DESCRIPTION>
+  !  Write out restart files registered through register_restart_file
+  ! </DESCRIPTION>
+  subroutine atmosphere_restart(timestamp)
+    character(len=*),  intent(in) :: timestamp
+
+    call fv_write_restart(Atm(mygrid), timestamp)
+
+  end subroutine atmosphere_restart
+  ! </SUBROUTINE>
+
+
+ subroutine atmosphere_resolution (i_size, j_size, global)
+   integer, intent(out)          :: i_size, j_size
+   logical, intent(in), optional :: global
+   logical :: local
+
+   local = .true.
+   if( PRESENT(global) ) local = .NOT.global
+
+   if( local ) then
+       i_size = iec - isc + 1
+       j_size = jec - jsc + 1
+   else
+       i_size = npx - 1
+       j_size = npy - 1
+   end if
+
+ end subroutine atmosphere_resolution
+
+
+ subroutine atmosphere_pref (p_ref)
+   real, dimension(:,:), intent(inout) :: p_ref
+
+   p_ref = pref
+
+ end subroutine atmosphere_pref
+
+ subroutine atmosphere_control_data (i1, i2, j1, j2, kt, p_hydro, hydro, do_uni_zfull) !miz
+   integer, intent(out)           :: i1, i2, j1, j2, kt
+   logical, intent(out), optional :: p_hydro, hydro, do_uni_zfull !miz
+   i1 = Atm(mygrid)%bd%isc
+   i2 = Atm(mygrid)%bd%iec
+   j1 = Atm(mygrid)%bd%jsc
+   j2 = Atm(mygrid)%bd%jec
+   kt = Atm(mygrid)%npz
+
+   if (present(p_hydro)) p_hydro = Atm(mygrid)%flagstruct%phys_hydrostatic
+   if (present(  hydro))   hydro = Atm(mygrid)%flagstruct%hydrostatic
+   if (present(do_uni_zfull)) do_uni_zfull = Atm(mygrid)%flagstruct%do_uni_zfull
+
+ end subroutine atmosphere_control_data
+
+
+ subroutine atmosphere_cell_area  (area_out)
+   real, dimension(:,:),  intent(out)          :: area_out
+
+   area_out(1:iec-isc+1, 1:jec-jsc+1) =  Atm(mygrid)%gridstruct%area (isc:iec,jsc:jec)
+
+ end subroutine atmosphere_cell_area
+
+
+
+ subroutine atmosphere_grid_center (lon, lat)
+!---------------------------------------------------------------
+!    returns the longitude and latitude cell centers
+!---------------------------------------------------------------
+    real(kind=kind_phys), intent(out) :: lon(:,:), lat(:,:)   ! Unit: radian
+! Local data:
+    integer i,j
+
+    do j=jsc,jec
+       do i=isc,iec
+          lon(i-isc+1,j-jsc+1) = Atm(mygrid)%gridstruct%agrid_64(i,j,1)
+          lat(i-isc+1,j-jsc+1) = Atm(mygrid)%gridstruct%agrid_64(i,j,2)
+       enddo
+    end do
+
+ end subroutine atmosphere_grid_center
+
+
+
+ subroutine atmosphere_boundary (blon, blat, global)
+!---------------------------------------------------------------
+!    returns the longitude and latitude grid box edges
+!    for either the local PEs grid (default) or the global grid
+!---------------------------------------------------------------
+    real,    intent(out) :: blon(:,:), blat(:,:)   ! Unit: radian
+    logical, intent(in), optional :: global
+! Local data:
+    integer i,j
+
+    if( PRESENT(global) ) then
+      if (global) call mpp_error(FATAL, '==> global grid is no longer available &
+                               & in the Cubed Sphere')
+    endif
+
+    do j=jsc,jec+1
+       do i=isc,iec+1
+          blon(i-isc+1,j-jsc+1) = Atm(mygrid)%gridstruct%grid(i,j,1)
+          blat(i-isc+1,j-jsc+1) = Atm(mygrid)%gridstruct%grid(i,j,2)
+       enddo
+    end do
+
+ end subroutine atmosphere_boundary
+
+
+ subroutine set_atmosphere_pelist ()
+   call mpp_set_current_pelist(Atm(mygrid)%pelist, no_sync=.TRUE.)
+ end subroutine set_atmosphere_pelist
+
+
+ subroutine atmosphere_domain ( fv_domain )
+   type(domain2d), intent(out) :: fv_domain
+!  returns the domain2d variable associated with the coupling grid
+!  note: coupling is done using the mass/temperature grid with no halos
+
+   fv_domain = Atm(mygrid)%domain_for_coupler
+
+ end subroutine atmosphere_domain
+
+
+
+ subroutine get_atmosphere_axes ( axes )
+   integer, intent(out) :: axes (:)
+
+!----- returns the axis indices for the atmospheric (mass) grid -----
+   if ( size(axes(:)) < 0 .or. size(axes(:)) > 4 ) call error_mesg (    &
+                               'get_atmosphere_axes in atmosphere_mod', &
+                               'size of argument is incorrect', FATAL   )
+
+   axes (1:size(axes(:))) = Atm(mygrid)%atmos_axes (1:size(axes(:)))
+
+ end subroutine get_atmosphere_axes
+
+
+
+ subroutine get_bottom_mass ( t_bot, tr_bot, p_bot, z_bot, p_surf, slp )
+!--------------------------------------------------------------
+! returns temp, sphum, pres, height at the lowest model level
+! and surface pressure
+!--------------------------------------------------------------
+   real, intent(out), dimension(isc:iec,jsc:jec):: t_bot, p_bot, z_bot, p_surf
+   real, intent(out), optional, dimension(isc:iec,jsc:jec):: slp
+   real, intent(out), dimension(isc:iec,jsc:jec,nq):: tr_bot
+   integer :: i, j, m, k, kr
+   real    :: rrg, sigtop, sigbot
+   real, dimension(isc:iec,jsc:jec) :: tref
+   real, parameter :: tlaps = 6.5e-3
+
+   rrg  = rdgas / grav
+
+   do j=jsc,jec
+      do i=isc,iec
+         p_surf(i,j) = Atm(mygrid)%ps(i,j)
+         t_bot(i,j) = Atm(mygrid)%pt(i,j,npz)
+         p_bot(i,j) = Atm(mygrid)%delp(i,j,npz)/(Atm(mygrid)%peln(i,npz+1,j)-Atm(mygrid)%peln(i,npz,j))
+         z_bot(i,j) = rrg*t_bot(i,j)*(1.+zvir*Atm(mygrid)%q(i,j,npz,sphum)) *  &
+                      (1. - Atm(mygrid)%pe(i,npz,j)/p_bot(i,j))
+      enddo
+   enddo
+
+   if ( present(slp) ) then
+     ! determine 0.8 sigma reference level
+     sigtop = Atm(mygrid)%ak(1)/Atm(mygrid)%flagstruct%p_ref+Atm(mygrid)%bk(1)
+     do k = 1, npz
+        sigbot = Atm(mygrid)%ak(k+1)/Atm(mygrid)%flagstruct%p_ref+Atm(mygrid)%bk(k+1)
+        if (sigbot+sigtop > 1.6) then
+           kr = k
+           exit
+        endif
+        sigtop = sigbot
+     enddo
+     do j=jsc,jec
+        do i=isc,iec
+           ! sea level pressure
+           tref(i,j) = Atm(mygrid)%pt(i,j,kr) * (Atm(mygrid)%delp(i,j,kr)/ &
+                            ((Atm(mygrid)%peln(i,kr+1,j)-Atm(mygrid)%peln(i,kr,j))*Atm(mygrid)%ps(i,j)))**(-rrg*tlaps)
+           slp(i,j) = Atm(mygrid)%ps(i,j)*(1.+tlaps*Atm(mygrid)%phis(i,j)/(tref(i,j)*grav))**(1./(rrg*tlaps))
+        enddo
+     enddo
+   endif
+
+! Copy tracers
+   do m=1,nq
+      do j=jsc,jec
+         do i=isc,iec
+            tr_bot(i,j,m) = Atm(mygrid)%q(i,j,npz,m)
+         enddo
+      enddo
+   enddo
+
+ end subroutine get_bottom_mass
+
+
+ subroutine get_bottom_wind ( u_bot, v_bot )
+!-----------------------------------------------------------
+! returns u and v on the mass grid at the lowest model level
+!-----------------------------------------------------------
+   real, intent(out), dimension(isc:iec,jsc:jec):: u_bot, v_bot
+   integer i, j
+
+   do j=jsc,jec
+      do i=isc,iec
+         u_bot(i,j) = Atm(mygrid)%u_srf(i,j)
+         v_bot(i,j) = Atm(mygrid)%v_srf(i,j)
+      enddo
+   enddo
+
+ end subroutine get_bottom_wind
+
+
+
+ subroutine get_stock_pe(index, value)
+   integer, intent(in) :: index
+   real,   intent(out) :: value
+
+#ifdef USE_STOCK
+   include 'stock.inc'
+#endif
+
+   real wm(isc:iec,jsc:jec)
+   integer i,j,k
+   real, pointer :: area(:,:)
+
+   area => Atm(mygrid)%gridstruct%area
+
+   select case (index)
+
+#ifdef USE_STOCK
+   case (ISTOCK_WATER)
+#else
+   case (1)
+#endif
+
+!----------------------
+! Perform vertical sum:
+!----------------------
+     wm = 0.
+     do j=jsc,jec
+        do k=1,npz
+           do i=isc,iec
+! Warning: the following works only with AM2 physics: water vapor; cloud water, cloud ice.
+              wm(i,j) = wm(i,j) + Atm(mygrid)%delp(i,j,k) * ( Atm(mygrid)%q(i,j,k,sphum)   +  &
+                                                              Atm(mygrid)%q(i,j,k,liq_wat) +  &
+                                                              Atm(mygrid)%q(i,j,k,ice_wat) )
+           enddo
+        enddo
+     enddo
+
+!----------------------
+! Horizontal sum:
+!----------------------
+     value = 0.
+     do j=jsc,jec
+        do i=isc,iec
+           value = value + wm(i,j)*area(i,j)
+        enddo
+     enddo
+     value = value/grav
+
+   case default
+     value = 0.0
+   end select
+
+ end subroutine get_stock_pe
+
+
+ subroutine atmosphere_state_update (Time, Physics_tendency, Physics, Atm_block)
+   type(time_type),intent(in)      :: Time
+   type (physics_tendency_type),   intent(in) :: Physics_tendency
+   type (physics_type),    intent(in) :: Physics
+   type (block_control_type), intent(in) :: Atm_block
+   type(time_type) :: Time_prev, Time_next
+!--- local variables ---
+   integer :: i, j, k, n, w_diff, nt_dyn
+   integer :: nb, ibs, ibe, jbs, jbe
+   real ::  rcp
+
+   Time_prev = Time
+   Time_next = Time + Time_step_atmos
+
+   n = mygrid
+
+   call set_domain ( Atm(mygrid)%domain )
+
+!--- put u/v tendencies into haloed arrays u_dt and v_dt
+!$OMP parallel do default(shared) private(nb, ibs, ibe, jbs, jbe)
+   do nb = 1,Atm_block%nblks
+     ibs = Atm_block%ibs(nb)
+     ibe = Atm_block%ibe(nb)
+     jbs = Atm_block%jbs(nb)
+     jbe = Atm_block%jbe(nb)
+
+     u_dt(ibs:ibe,jbs:jbe,:)   = Physics_tendency%block(nb)%u_dt
+     v_dt(ibs:ibe,jbs:jbe,:)   = Physics_tendency%block(nb)%v_dt
+     t_dt(ibs:ibe,jbs:jbe,:)   = Physics_tendency%block(nb)%t_dt
+     q_dt(ibs:ibe,jbs:jbe,:,:) = Physics_tendency%block(nb)%q_dt
+
+!--- diagnostic tracers are being updated in-place
+!--- tracer fields must be returned to the Atm structure
+     Atm(mygrid)%qdiag(ibs:ibe,jbs:jbe,:,:) = Physics_tendency%block(nb)%qdiag
+
+   enddo
+
+   w_diff = get_tracer_index (MODEL_ATMOS, 'w_diff' )
+   nt_dyn = ncnst-pnats   !nothing more than nq
+   if ( w_diff /= NO_TRACER ) then
+      nt_dyn = nt_dyn - 1
+   endif
+
+!--- adjust w and heat tendency for non-hydrostatic case
+#ifdef USE_Q_DT
+    if ( .not.Atm(n)%flagstruct%hydrostatic .and. w_diff /= NO_TRACER ) then
+      rcp = 1. / cp_air
+!$OMP parallel do default (none) &
+!$OMP              shared (jsc, jec, isc, iec, n, w_diff, Atm, q_dt, t_dt, rcp, dt_atmos) &
+!$OMP             private (i, j, k)
+       do k=1, Atm(n)%npz
+         do j=jsc, jec
+           do i=isc, iec
+             Atm(n)%q(i,j,k,w_diff) = q_dt(i,j,k,w_diff) ! w tendency due to phys
+! Heating due to loss of KE (vertical diffusion of w)
+             t_dt(i,j,k) = t_dt(i,j,k) - q_dt(i,j,k,w_diff)*rcp*&
+                                     (Atm(n)%w(i,j,k)+0.5*dt_atmos*q_dt(i,j,k,w_diff))
+             Atm(n)%w(i,j,k) = Atm(n)%w(i,j,k) + dt_atmos*Atm(n)%q(i,j,k,w_diff)
+           enddo
+         enddo
+       enddo
+    endif
+#endif
+
+   call mpp_clock_begin (id_dynam)
+       call timing_on('FV_UPDATE_PHYS')
+    call fv_update_phys( dt_atmos, isc, iec, jsc, jec, isd, ied, jsd, jed, Atm(n)%ng, nt_dyn, &
+                         Atm(n)%u,  Atm(n)%v,   Atm(n)%w,  Atm(n)%delp, Atm(n)%pt,         &
+                         Atm(n)%q,  Atm(n)%qdiag,                                          &
+                         Atm(n)%ua, Atm(n)%va,  Atm(n)%ps, Atm(n)%pe,   Atm(n)%peln,       &
+                         Atm(n)%pk, Atm(n)%pkz, Atm(n)%ak, Atm(n)%bk,   Atm(n)%phis,       &
+                         Atm(n)%u_srf, Atm(n)%v_srf, Atm(n)%ts, Atm(n)%delz,               &
+                         Atm(n)%flagstruct%hydrostatic, u_dt, v_dt, t_dt,                  &
+                         .true., Time_next, Atm(n)%flagstruct%nudge, Atm(n)%gridstruct,    &
+                         Atm(n)%gridstruct%agrid(:,:,1), Atm(n)%gridstruct%agrid(:,:,2),   &
+                         Atm(n)%npx, Atm(n)%npy, Atm(n)%npz, Atm(n)%flagstruct,            &
+                         Atm(n)%neststruct, Atm(n)%bd, Atm(n)%domain, &
+                         Atm(n)%ptop, Atm(n)%phys_diag, Atm(n)%nudge_diag, q_dt)
+       call timing_off('FV_UPDATE_PHYS')
+   call mpp_clock_end (id_dynam)
+
+!--- nesting update after updating atmospheric variables with
+!--- physics tendencies
+    if (ngrids > 1 .and. p_split > 0) then
+       call timing_on('TWOWAY_UPDATE')
+       call twoway_nesting(Atm, ngrids, grids_on_this_pe, zvir, fv_time, mygrid)
+       call timing_off('TWOWAY_UPDATE')
+    endif
+
+!--- cmip6 total tendencies of temperature and specific humidity
+   if (query_cmip_diag_id(ID_tnt)) &
+                 used = send_cmip_data_3d ( ID_tnt, (Atm(mygrid)%pt(isc:iec,jsc:jec,:)-ttend(:,:,:))/dt_atmos, Time)
+   if (query_cmip_diag_id(ID_tnhus)) &
+                  used = send_cmip_data_3d (ID_tnhus, (Atm(mygrid)%q(isc:iec,jsc:jec,:,sphum)-qtend(:,:,:,sphum))/dt_atmos, Time)
+
+   call nullify_domain()
+  !---- diagnostics for FV dynamics -----
+   if (Atm(mygrid)%flagstruct%print_freq /= -99) then
+     call mpp_clock_begin(id_fv_diag)
+     call timing_on('FV_DIAG')
+
+     fv_time = Time_next
+     call get_time (fv_time, seconds,  days)
+
+     call fv_diag(Atm(mygrid:mygrid), zvir, fv_time, Atm(mygrid)%flagstruct%print_freq)
+      if (Atm(mygrid)%coarse_graining%write_coarse_diagnostics) then
+         call fv_coarse_diag(Atm(mygrid:mygrid), fv_time)
+      endif
+     call fv_cmip_diag(Atm(mygrid:mygrid), zvir, fv_time)
+
+     call timing_off('FV_DIAG')
+     call mpp_clock_end(id_fv_diag)
+   endif
+
+ end subroutine atmosphere_state_update
+
+
+ subroutine adiabatic_init(zvir,nudge_dz)
+   real, allocatable, dimension(:,:,:):: u0, v0, t0, dz0, dp0
+   real, intent(in):: zvir
+   logical, intent(inout):: nudge_dz
+!  real, parameter:: wt = 1.  ! was 2.
+   real, parameter:: wt = 2.
+!***********
+! Haloe Data
+!***********
+   real, parameter::    q1_h2o = 2.2E-6
+   real, parameter::    q7_h2o = 3.8E-6
+   real, parameter::  q100_h2o = 3.8E-6
+   real, parameter:: q1000_h2o = 3.1E-6
+   real, parameter:: q2000_h2o = 2.8E-6
+   real, parameter:: q3000_h2o = 3.0E-6
+   real:: xt, p00, q00
+   integer:: isc, iec, jsc, jec, npz
+   integer:: m, n, i,j,k, ngc
+
+   character(len=80) :: errstr
+
+   xt = 1./(1.+wt)
+
+   write(errstr,'(A, I4, A)') 'Performing adiabatic init',  Atm(mygrid)%flagstruct%na_init, ' times'
+   call mpp_error(NOTE, errstr)
+   sphum = get_tracer_index (MODEL_ATMOS, 'sphum' )
+
+    npz = Atm(mygrid)%npz
+
+    isc = Atm(mygrid)%bd%isc
+    iec = Atm(mygrid)%bd%iec
+    jsc = Atm(mygrid)%bd%jsc
+    jec = Atm(mygrid)%bd%jec
+
+    ngc = Atm(mygrid)%ng
+    isd = isc - ngc
+    ied = iec + ngc
+    jsd = jsc - ngc
+    jed = jec + ngc
+
+     call timing_on('adiabatic_init')
+     do_adiabatic_init = .true.
+
+     allocate ( u0(isc:iec,  jsc:jec+1, npz) )
+     allocate ( v0(isc:iec+1,jsc:jec,   npz) )
+     allocate (dp0(isc:iec,jsc:jec, npz) )
+
+     if ( Atm(mygrid)%flagstruct%hydrostatic ) nudge_dz = .false.
+
+     if ( nudge_dz ) then
+          allocate (dz0(isc:iec,jsc:jec, npz) )
+     else
+          allocate ( t0(isc:iec,jsc:jec, npz) )
+     endif
+
+!$omp parallel do default (none) &
+!$omp              shared (nudge_dz, npz, jsc, jec, isc, iec, n, sphum, u0, v0, t0, dz0, dp0, Atm, zvir, mygrid) &
+!$omp             private (k, j, i)
+       do k=1,npz
+          do j=jsc,jec+1
+             do i=isc,iec
+                u0(i,j,k) = Atm(mygrid)%u(i,j,k)
+             enddo
+          enddo
+          do j=jsc,jec
+             do i=isc,iec+1
+                v0(i,j,k) = Atm(mygrid)%v(i,j,k)
+             enddo
+          enddo
+          if ( nudge_dz ) then
+             do j=jsc,jec
+                do i=isc,iec
+                   dp0(i,j,k) = Atm(mygrid)%delp(i,j,k)
+                   dz0(i,j,k) = Atm(mygrid)%delz(i,j,k)
+                enddo
+             enddo
+          else
+             do j=jsc,jec
+                do i=isc,iec
+                   t0(i,j,k) = Atm(mygrid)%pt(i,j,k)*(1.+zvir*Atm(mygrid)%q(i,j,k,sphum))  ! virt T
+                   dp0(i,j,k) = Atm(mygrid)%delp(i,j,k)
+                enddo
+             enddo
+          endif
+       enddo
+
+     do m=1,Atm(mygrid)%flagstruct%na_init
+! Forward call
+    call fv_dynamics(Atm(mygrid)%npx, Atm(mygrid)%npy, npz,  nq, Atm(mygrid)%ng, dt_atmos, 0.,      &
+                     Atm(mygrid)%flagstruct%fill, Atm(mygrid)%flagstruct%reproduce_sum, kappa, cp_air, zvir,  &
+                     Atm(mygrid)%ptop, Atm(mygrid)%ks, nq, Atm(mygrid)%flagstruct%n_split,        &
+                     Atm(mygrid)%flagstruct%q_split, Atm(mygrid)%u, Atm(mygrid)%v, Atm(mygrid)%w,         &
+                     Atm(mygrid)%delz, Atm(mygrid)%flagstruct%hydrostatic,                      &
+                     Atm(mygrid)%pt, Atm(mygrid)%delp, Atm(mygrid)%q, Atm(mygrid)%ps,                     &
+                     Atm(mygrid)%pe, Atm(mygrid)%pk, Atm(mygrid)%peln, Atm(mygrid)%pkz, Atm(mygrid)%phis,      &
+                     Atm(mygrid)%q_con, Atm(mygrid)%omga, Atm(mygrid)%ua, Atm(mygrid)%va, Atm(mygrid)%uc, Atm(mygrid)%vc, &
+                     Atm(mygrid)%ak, Atm(mygrid)%bk, Atm(mygrid)%mfx, Atm(mygrid)%mfy,                    &
+                     Atm(mygrid)%cx, Atm(mygrid)%cy, Atm(mygrid)%ze0, Atm(mygrid)%flagstruct%hybrid_z,    &
+                     Atm(mygrid)%gridstruct, Atm(mygrid)%flagstruct,                            &
+                     Atm(mygrid)%neststruct, Atm(mygrid)%idiag, Atm(mygrid)%bd, Atm(mygrid)%parent_grid,  &
+                     Atm(mygrid)%domain, Atm(mygrid)%inline_mp)
+! Backward
+    call fv_dynamics(Atm(mygrid)%npx, Atm(mygrid)%npy, npz,  nq, Atm(mygrid)%ng, -dt_atmos, 0.,      &
+                     Atm(mygrid)%flagstruct%fill, Atm(mygrid)%flagstruct%reproduce_sum, kappa, cp_air, zvir,  &
+                     Atm(mygrid)%ptop, Atm(mygrid)%ks, nq, Atm(mygrid)%flagstruct%n_split,        &
+                     Atm(mygrid)%flagstruct%q_split, Atm(mygrid)%u, Atm(mygrid)%v, Atm(mygrid)%w,         &
+                     Atm(mygrid)%delz, Atm(mygrid)%flagstruct%hydrostatic,                      &
+                     Atm(mygrid)%pt, Atm(mygrid)%delp, Atm(mygrid)%q, Atm(mygrid)%ps,                     &
+                     Atm(mygrid)%pe, Atm(mygrid)%pk, Atm(mygrid)%peln, Atm(mygrid)%pkz, Atm(mygrid)%phis,      &
+                     Atm(mygrid)%q_con, Atm(mygrid)%omga, Atm(mygrid)%ua, Atm(mygrid)%va, Atm(mygrid)%uc, Atm(mygrid)%vc, &
+                     Atm(mygrid)%ak, Atm(mygrid)%bk, Atm(mygrid)%mfx, Atm(mygrid)%mfy,                    &
+                     Atm(mygrid)%cx, Atm(mygrid)%cy, Atm(mygrid)%ze0, Atm(mygrid)%flagstruct%hybrid_z,    &
+                     Atm(mygrid)%gridstruct, Atm(mygrid)%flagstruct,                            &
+                     Atm(mygrid)%neststruct, Atm(mygrid)%idiag, Atm(mygrid)%bd, Atm(mygrid)%parent_grid,  &
+                     Atm(mygrid)%domain, Atm(mygrid)%inline_mp)
+! Nudging back to IC
+!$omp parallel do default (none) &
+!$omp              shared (pref, npz, jsc, jec, isc, iec, n, sphum, Atm, u0, v0, t0, dp0, xt, zvir, mygrid, nudge_dz, dz0) &
+!$omp             private (i, j, k, p00, q00)
+       do k=1,npz
+          do j=jsc,jec+1
+             do i=isc,iec
+                Atm(mygrid)%u(i,j,k) = xt*(Atm(mygrid)%u(i,j,k) + wt*u0(i,j,k))
+             enddo
+          enddo
+          do j=jsc,jec
+             do i=isc,iec+1
+                Atm(mygrid)%v(i,j,k) = xt*(Atm(mygrid)%v(i,j,k) + wt*v0(i,j,k))
+             enddo
+          enddo
+          if( Atm(mygrid)%flagstruct%nudge_qv ) then
+! SJL note: Nudging water vaport towards HALOE climatology:
+! In case of better IC (IFS) this step may not be necessary
+             p00 = Atm(mygrid)%pe(isc,k,jsc)
+             if ( p00 < 30.E2 ) then
+                if ( p00 < 1. ) then
+                     q00 = q1_h2o
+                elseif ( p00 <= 7. .and. p00 >= 1. ) then
+                     q00 = q1_h2o + (q7_h2o-q1_h2o)*log(pref(k,1)/1.)/log(7.)
+                elseif ( p00 < 100. .and. p00 >= 7. ) then
+                     q00 = q7_h2o + (q100_h2o-q7_h2o)*log(pref(k,1)/7.)/log(100./7.)
+                elseif ( p00 < 1000. .and. p00 >= 100. ) then
+                     q00 = q100_h2o + (q1000_h2o-q100_h2o)*log(pref(k,1)/1.E2)/log(10.)
+                elseif ( p00 < 2000. .and. p00 >= 1000. ) then
+                     q00 = q1000_h2o + (q2000_h2o-q1000_h2o)*log(pref(k,1)/1.E3)/log(2.)
+                else
+                     q00 = q2000_h2o + (q3000_h2o-q2000_h2o)*log(pref(k,1)/2.E3)/log(1.5)
+                endif
+                do j=jsc,jec
+                   do i=isc,iec
+                      Atm(mygrid)%q(i,j,k,sphum) = xt*(Atm(mygrid)%q(i,j,k,sphum) + wt*q00)
+                   enddo
+                enddo
+             endif
+          endif
+          if ( nudge_dz ) then
+             do j=jsc,jec
+                do i=isc,iec
+                   Atm(mygrid)%delp(i,j,k) = xt*(Atm(mygrid)%delp(i,j,k) + wt*dp0(i,j,k))
+                   Atm(mygrid)%delz(i,j,k) = xt*(Atm(mygrid)%delz(i,j,k) + wt*dz0(i,j,k))
+                enddo
+             enddo
+          else
+             do j=jsc,jec
+                do i=isc,iec
+                   Atm(mygrid)%pt(i,j,k) = xt*(Atm(mygrid)%pt(i,j,k) + wt*t0(i,j,k)/(1.+zvir*Atm(mygrid)%q(i,j,k,sphum)))
+                   Atm(mygrid)%delp(i,j,k) = xt*(Atm(mygrid)%delp(i,j,k) + wt*dp0(i,j,k))
+                enddo
+             enddo
+          endif
+
+       enddo
+
+! Backward
+    call fv_dynamics(Atm(mygrid)%npx, Atm(mygrid)%npy, npz,  nq, Atm(mygrid)%ng, -dt_atmos, 0.,      &
+                     Atm(mygrid)%flagstruct%fill, Atm(mygrid)%flagstruct%reproduce_sum, kappa, cp_air, zvir,  &
+                     Atm(mygrid)%ptop, Atm(mygrid)%ks, nq, Atm(mygrid)%flagstruct%n_split,        &
+                     Atm(mygrid)%flagstruct%q_split, Atm(mygrid)%u, Atm(mygrid)%v, Atm(mygrid)%w,         &
+                     Atm(mygrid)%delz, Atm(mygrid)%flagstruct%hydrostatic,                      &
+                     Atm(mygrid)%pt, Atm(mygrid)%delp, Atm(mygrid)%q, Atm(mygrid)%ps,                     &
+                     Atm(mygrid)%pe, Atm(mygrid)%pk, Atm(mygrid)%peln, Atm(mygrid)%pkz, Atm(mygrid)%phis,      &
+                     Atm(mygrid)%q_con, Atm(mygrid)%omga, Atm(mygrid)%ua, Atm(mygrid)%va, Atm(mygrid)%uc, Atm(mygrid)%vc, &
+                     Atm(mygrid)%ak, Atm(mygrid)%bk, Atm(mygrid)%mfx, Atm(mygrid)%mfy,                    &
+                     Atm(mygrid)%cx, Atm(mygrid)%cy, Atm(mygrid)%ze0, Atm(mygrid)%flagstruct%hybrid_z,    &
+                     Atm(mygrid)%gridstruct, Atm(mygrid)%flagstruct,                            &
+                     Atm(mygrid)%neststruct, Atm(mygrid)%idiag, Atm(mygrid)%bd, Atm(mygrid)%parent_grid,  &
+                     Atm(mygrid)%domain, Atm(mygrid)%inline_mp)
+! Forward call
+    call fv_dynamics(Atm(mygrid)%npx, Atm(mygrid)%npy, npz,  nq, Atm(mygrid)%ng, dt_atmos, 0.,      &
+                     Atm(mygrid)%flagstruct%fill, Atm(mygrid)%flagstruct%reproduce_sum, kappa, cp_air, zvir,  &
+                     Atm(mygrid)%ptop, Atm(mygrid)%ks, nq, Atm(mygrid)%flagstruct%n_split,        &
+                     Atm(mygrid)%flagstruct%q_split, Atm(mygrid)%u, Atm(mygrid)%v, Atm(mygrid)%w,         &
+                     Atm(mygrid)%delz, Atm(mygrid)%flagstruct%hydrostatic,                      &
+                     Atm(mygrid)%pt, Atm(mygrid)%delp, Atm(mygrid)%q, Atm(mygrid)%ps,                     &
+                     Atm(mygrid)%pe, Atm(mygrid)%pk, Atm(mygrid)%peln, Atm(mygrid)%pkz, Atm(mygrid)%phis,      &
+                     Atm(mygrid)%q_con, Atm(mygrid)%omga, Atm(mygrid)%ua, Atm(mygrid)%va, Atm(mygrid)%uc, Atm(mygrid)%vc, &
+                     Atm(mygrid)%ak, Atm(mygrid)%bk, Atm(mygrid)%mfx, Atm(mygrid)%mfy,                    &
+                     Atm(mygrid)%cx, Atm(mygrid)%cy, Atm(mygrid)%ze0, Atm(mygrid)%flagstruct%hybrid_z,    &
+                     Atm(mygrid)%gridstruct, Atm(mygrid)%flagstruct,                            &
+                     Atm(mygrid)%neststruct, Atm(mygrid)%idiag, Atm(mygrid)%bd, Atm(mygrid)%parent_grid,  &
+                     Atm(mygrid)%domain, Atm(mygrid)%inline_mp)
+! Nudging back to IC
+!$omp parallel do default (none) &
+!$omp              shared (nudge_dz,npz, jsc, jec, isc, iec, n, sphum, Atm, u0, v0, t0, dz0, dp0, xt, zvir, mygrid) &
+!$omp             private (i, j, k)
+       do k=1,npz
+          do j=jsc,jec+1
+             do i=isc,iec
+                Atm(mygrid)%u(i,j,k) = xt*(Atm(mygrid)%u(i,j,k) + wt*u0(i,j,k))
+             enddo
+          enddo
+          do j=jsc,jec
+             do i=isc,iec+1
+                Atm(mygrid)%v(i,j,k) = xt*(Atm(mygrid)%v(i,j,k) + wt*v0(i,j,k))
+             enddo
+          enddo
+          if ( nudge_dz ) then
+             do j=jsc,jec
+             do i=isc,iec
+                Atm(mygrid)%delp(i,j,k) = xt*(Atm(mygrid)%delp(i,j,k) + wt*dp0(i,j,k))
+                Atm(mygrid)%delz(i,j,k) = xt*(Atm(mygrid)%delz(i,j,k) + wt*dz0(i,j,k))
+             enddo
+             enddo
+          else
+             do j=jsc,jec
+             do i=isc,iec
+                Atm(mygrid)%pt(i,j,k) = xt*(Atm(mygrid)%pt(i,j,k) + wt*t0(i,j,k)/(1.+zvir*Atm(mygrid)%q(i,j,k,sphum)))
+                Atm(mygrid)%delp(i,j,k) = xt*(Atm(mygrid)%delp(i,j,k) + wt*dp0(i,j,k))
+             enddo
+             enddo
+          endif
+       enddo
+
+     enddo
+
+     deallocate ( u0 )
+     deallocate ( v0 )
+     deallocate (dp0 )
+     if ( allocated(t0) )  deallocate ( t0 )
+     if ( allocated(dz0) ) deallocate ( dz0 )
+
+     do_adiabatic_init = .false.
+     call timing_off('adiabatic_init')
+
+ end subroutine adiabatic_init
+
+
+ subroutine atmos_physics_driver_inputs (Physics, Atm_block, Physics_tendency)
+   type (physics_type),  intent(inout) :: Physics
+   type (block_control_type), intent(in) :: Atm_block
+   type (physics_tendency_type), intent(inout), optional :: Physics_tendency
+!--- local variabls
+   integer :: nb, ibs, ibe, jbs, jbe
+
+!---------------------------------------------------------------------
+! use most up to date atmospheric properties when running serially
+!---------------------------------------------------------------------
+!$OMP parallel do default(shared) private(nb, ibs, ibe, jbs, jbe)
+   do nb = 1, Atm_block%nblks
+     ibs = Atm_block%ibs(nb)
+     ibe = Atm_block%ibe(nb)
+     jbs = Atm_block%jbs(nb)
+     jbe = Atm_block%jbe(nb)
+
+     Physics%block(nb)%phis = Atm(mygrid)%phis(ibs:ibe,jbs:jbe)
+     Physics%block(nb)%u    = Atm(mygrid)%ua(ibs:ibe,jbs:jbe,:)
+     Physics%block(nb)%v    = Atm(mygrid)%va(ibs:ibe,jbs:jbe,:)
+     Physics%block(nb)%t    = Atm(mygrid)%pt(ibs:ibe,jbs:jbe,:)
+     Physics%block(nb)%q    = Atm(mygrid)%q(ibs:ibe,jbs:jbe,:,:)
+     Physics%block(nb)%omega= Atm(mygrid)%omga(ibs:ibe,jbs:jbe,:)
+     Physics%block(nb)%pe   = Atm(mygrid)%pe(ibs:ibe,:,jbs:jbe)
+     Physics%block(nb)%peln = Atm(mygrid)%peln(ibs:ibe,:,jbs:jbe)
+     Physics%block(nb)%delp = Atm(mygrid)%delp(ibs:ibe,jbs:jbe,:)
+     if (.not.Physics%control%phys_hydrostatic) then
+        Physics%block(nb)%delz = Atm(mygrid)%delz(ibs:ibe,jbs:jbe,:)
+        Physics%block(nb)%w    = Atm(mygrid)%w(ibs:ibe,jbs:jbe,:)
+     endif
+     if (_ALLOCATED(Physics%block(nb)%tmp_4d)) &
+        Physics%block(nb)%tmp_4d = Atm(mygrid)%qdiag(ibs:ibe,jbs:jbe,:,:)
+
+     call fv_compute_p_z (Atm_block%npz, Physics%block(nb)%phis, Physics%block(nb)%pe, &
+                          Physics%block(nb)%peln, Physics%block(nb)%delp, Physics%block(nb)%delz, &
+                          Physics%block(nb)%t, Physics%block(nb)%q(:,:,:,Physics%control%sphum), &
+                          Physics%block(nb)%p_full, Physics%block(nb)%p_half, &
+                          Physics%block(nb)%z_full, Physics%block(nb)%z_half, &
+#ifdef USE_COND
+                          Atm(mygrid)%q_con(ibs:ibe,jbs:jbe,:), &
+#else
+                          Atm(mygrid)%q_con, &
+#endif
+                          Physics%control%phys_hydrostatic, Physics%control%do_uni_zfull) !miz
+
+     if (PRESENT(Physics_tendency)) then
+!--- copy the dynamics tendencies into the physics tendencies
+!--- if one wants to run physics concurrent with dynamics,
+!--- these values would be zeroed out and accumulated
+!--- in the atmosphere_state_update
+
+       Physics_tendency%block(nb)%u_dt = u_dt(ibs:ibe,jbs:jbe,:)
+       Physics_tendency%block(nb)%v_dt = v_dt(ibs:ibe,jbs:jbe,:)
+       Physics_tendency%block(nb)%t_dt = t_dt(ibs:ibe,jbs:jbe,:)
+       Physics_tendency%block(nb)%q_dt = q_dt(ibs:ibe,jbs:jbe,:,:)
+       Physics_tendency%block(nb)%qdiag = Atm(mygrid)%qdiag(ibs:ibe,jbs:jbe,:,:)
+     endif
+   enddo
+
+ end subroutine atmos_physics_driver_inputs
+
+
+ subroutine atmos_radiation_driver_inputs (Time, Radiation, Atm_block)
+   type (time_type),          intent(in)    :: Time
+   type (radiation_type),     intent(inout) :: Radiation
+   type (block_control_type), intent(in)    :: Atm_block
+!--- local variables
+   integer :: nb, ibs, ibe, jbs, jbe
+
+!---------------------------------------------------------------------
+! use most up to date atmospheric properties when running serially
+!---------------------------------------------------------------------
+!$OMP parallel do default(shared) private(nb, ibs, ibe, jbs, jbe)
+   do nb = 1,Atm_block%nblks
+     ibs = Atm_block%ibs(nb)
+     ibe = Atm_block%ibe(nb)
+     jbs = Atm_block%jbs(nb)
+     jbe = Atm_block%jbe(nb)
+
+     Radiation%block(nb)%phis = Atm(mygrid)%phis(ibs:ibe,jbs:jbe)
+     Radiation%block(nb)%t    = Atm(mygrid)%pt(ibs:ibe,jbs:jbe,:)
+     Radiation%block(nb)%q    = Atm(mygrid)%q(ibs:ibe,jbs:jbe,:,:)
+     Radiation%block(nb)%pe   = Atm(mygrid)%pe(ibs:ibe,:,jbs:jbe)
+     Radiation%block(nb)%peln = Atm(mygrid)%peln(ibs:ibe,:,jbs:jbe)
+     Radiation%block(nb)%delp = Atm(mygrid)%delp(ibs:ibe,jbs:jbe,:)
+     if (.not.Radiation%control%phys_hydrostatic) &
+        Radiation%block(nb)%delz = Atm(mygrid)%delz(ibs:ibe,jbs:jbe,:)
+
+     call fv_compute_p_z (Atm_block%npz, Radiation%block(nb)%phis, Radiation%block(nb)%pe, &
+                          Radiation%block(nb)%peln, Radiation%block(nb)%delp, Radiation%block(nb)%delz, &
+                          Radiation%block(nb)%t, Radiation%block(nb)%q(:,:,:,Radiation%control%sphum), &
+                          Radiation%block(nb)%p_full, Radiation%block(nb)%p_half, &
+                          Radiation%block(nb)%z_full, Radiation%block(nb)%z_half, &
+#ifdef USE_COND
+                          Atm(mygrid)%q_con(ibs:ibe,jbs:jbe,:), &
+#else
+                          Atm(mygrid)%q_con, &
+#endif
+                          Radiation%control%phys_hydrostatic, Radiation%control%do_uni_zfull) !miz
+   enddo
+
+!----------------------------------------------------------------------
+! obtain pressure-weighted global mean co2 dry volume mixing ratio for
+! use by radiation package.
+!----------------------------------------------------------------------
+! compute_g_avg must be called here because it contains
+! mpp_sums that cannot be called during the concurrent radiation
+! phase due to the way in which MPI interacts with nested OpenMP
+!----------------------------------------------------------------------
+   call compute_g_avg(Time, 'co2', Radiation, Atm_block)
+   call compute_g_avg(Time, 'ch4', Radiation, Atm_block)
+
+ end subroutine atmos_radiation_driver_inputs
+
+
+
+ subroutine fv_compute_p_z (npz, phis, pe, peln, delp, delz, pt, q_sph, &
+                            p_full, p_half, z_full, z_half, q_con, hydrostatic, do_uni_zfull) !miz
+    integer, intent(in)  :: npz
+    real, dimension(:,:),   intent(in)  :: phis
+    real, dimension(:,:,:), intent(in)  :: pe, peln, delp, delz, q_con, pt, q_sph
+    real, dimension(:,:,:), intent(out) :: p_full, p_half, z_full, z_half
+    logical, intent(in)  :: hydrostatic, do_uni_zfull !miz
+!--- local variables
+    integer i,j,k,isiz,jsiz
+    real    tvm
+    real    :: zvir, rrg, ginv
+#ifdef USE_COND
+    real, dimension(size(pe,1),size(pe,3),size(pe,2)):: peg, pelng
+    real:: dlg
+#endif
+
+    isiz=size(phis,1)
+    jsiz=size(phis,2)
+    zvir = rvgas/rdgas - 1.
+    ginv = 1./ grav
+    rrg  = rdgas / grav
+
+!----------------------------------------------------
+! Compute pressure and height at full and half levels
+!----------------------------------------------------
+    z_half(:,:,npz+1) = phis(:,:) * ginv
+
+    do k=1,npz+1
+      do j=1,jsiz
+         do i=1,isiz
+           p_half(i,j,k) = pe(i,k,j)
+        enddo
+      enddo
+    enddo
+
+!--------- Hydrostatic option ----------------------------------------------
+    if (hydrostatic ) then
+#ifdef USE_COND
+    do j=1,jsiz
+       do i=1,isiz
+          peg(i,j,1) = pe(i,1,j)
+       enddo
+    end do
+    do k=2,npz+1
+       do j=1,jsiz
+          do i=1,isiz
+             peg(i,j,k) = peg(i,j,k-1) + delp(i,j,k-1)*(1.-q_con(i,j,k-1))
+          enddo
+       enddo
+    enddo
+#endif
+      do k=npz,1,-1
+        do j=1,jsiz
+          do i=1,isiz
+            tvm = rrg*pt(i,j,k)*(1.+zvir*q_sph(i,j,k))
+            p_full(i,j,k) = delp(i,j,k)/(peln(i,k+1,j)-peln(i,k,j))
+#ifdef USE_COND
+            dlg = log(peg(i,j,k+1)/peg(i,j,k))
+            z_full(i,j,k) = z_half(i,j,k+1) + tvm*(1.-peg(i,j,k)*dlg/(peg(i,j,k+1)-peg(i,j,k)))
+            z_half(i,j,k) = z_half(i,j,k+1) + tvm*dlg
+#else
+            z_full(i,j,k) = z_half(i,j,k+1) + tvm*(1.-p_half(i,j,k)/p_full(i,j,k))
+            z_half(i,j,k) = z_half(i,j,k+1) + tvm*(peln(i,k+1,j)-peln(i,k,j))
+#endif
+          enddo
+        enddo
+      enddo
+    else
+!--------- Non-Hydrostatic option ------------------------------------------
+      do k=npz,1,-1
+        do j=1,jsiz
+          do i=1,isiz
+            p_full(i,j,k) = delp(i,j,k)/(peln(i,k+1,j)-peln(i,k,j))
+            z_half(i,j,k) = z_half(i,j,k+1) - delz(i,j,k)
+            z_full(i,j,k) = 0.5*(z_half(i,j,k) + z_half(i,j,k+1))
+          enddo
+        enddo
+      enddo
+    endif
+    if (do_uni_zfull) then
+       do k=1,npz
+         z_full(:,:,k)=0.5*(z_half(:,:,k)+z_half(:,:,k+1))
+       enddo
+    endif
+  end subroutine fv_compute_p_z
+
+
+ subroutine reset_atmos_tracers (Physics, Physics_tendency, Atm_block)
+   type (physics_type), intent(in) :: Physics
+   type (physics_tendency_type), intent(in) :: Physics_tendency
+   type (block_control_type), intent(in) :: Atm_block
+!--- local variables
+   integer :: nb, ibs, ibe, jbs, jbe
+
+!--- After initialization by the physics, tracer fields must be
+!--- returned to the Atm structure.  This is because tracer driver
+!--- can reset the initial values
+!$OMP parallel do default(shared) private(nb, ibs, ibe, jbs, jbe)
+    do nb = 1, Atm_block%nblks
+      ibs = Atm_block%ibs(nb)
+      ibe = Atm_block%ibe(nb)
+      jbs = Atm_block%jbs(nb)
+      jbe = Atm_block%jbe(nb)
+
+      Atm(mygrid)%q(ibs:ibe,jbs:jbe,:,:) = Physics%block(nb)%q
+      Atm(mygrid)%qdiag(ibs:ibe,jbs:jbe,:,:) = Physics_tendency%block(nb)%qdiag
+    enddo
+
+ end subroutine reset_atmos_tracers
+#endif
+end module atmosphere_mod
diff --git a/model/dyn_core.F90 b/model/dyn_core.F90
index bfce3d1..1131907 100644
--- a/model/dyn_core.F90
+++ b/model/dyn_core.F90
@@ -785,7 +785,7 @@ contains
     endif
                                                      call timing_off('d_sw')
 
-    if( flagstruct%fill_dp ) call mix_dp(hydrostatic, w, delp, pt, npz, ak, bk, .false., flagstruct%fv_debug, bd, gridstruct)
+    if( flagstruct%fill_dp ) call mix_dp(hydrostatic, w, delp, pt, npz, ak, bk, .false., flagstruct%fv_debug, bd, gridstruct,flagstruct%p_ref)
 
                                                              call timing_on('COMM_TOTAL')
     call start_group_halo_update(i_pack(1), delp, domain, complete=.false.)
@@ -2031,9 +2031,10 @@ enddo    ! end k-loop
 end subroutine grad1_p_update
 
 
-subroutine mix_dp(hydrostatic, w, delp, pt, km, ak, bk, CG, fv_debug, bd, gridstruct)
+subroutine mix_dp(hydrostatic, w, delp, pt, km, ak, bk, CG, fv_debug, bd, gridstruct, p_ref)
 integer, intent(IN) :: km
 real   , intent(IN) :: ak(km+1), bk(km+1)
+real   , intent(IN) :: p_ref
 type(fv_grid_bounds_type), intent(IN) :: bd
 real, intent(INOUT), dimension(bd%isd:bd%ied,bd%jsd:bd%jed,km):: pt, delp
 real, intent(INOUT), dimension(bd%isd:,bd%jsd:,1:):: w
@@ -2069,14 +2070,14 @@ endif
 
 
 !$OMP parallel do default(none) shared(jfirst,jlast,km,ifirst,ilast,delp,ak,bk,pt, &
-!$OMP                                  hydrostatic,w,fv_debug,gridstruct) &
+!$OMP                                  hydrostatic,w,fv_debug,gridstruct,p_ref) &
 !$OMP                          private(ip, dpmin, dp)
 do 1000 j=jfirst,jlast
 
    ip = 0
 
    do k=1, km-1
-      dpmin = 0.01 * ( ak(k+1)-ak(k) + (bk(k+1)-bk(k))*1.E5 )
+      dpmin = 0.01 * ( ak(k+1)-ak(k) + (bk(k+1)-bk(k))*p_ref )
       do i=ifirst, ilast
          if(.not. delp(i,j,k) >= dpmin) then ! catches NaN
 !         if(delp(i,j,k) < dpmin) then
@@ -2093,7 +2094,7 @@ do 1000 j=jfirst,jlast
    enddo
 
    ! Bottom (k=km):
-   dpmin = 0.01 * ( ak(km+1)-ak(km) + (bk(km+1)-bk(km))*1.E5 )
+   dpmin = 0.01 * ( ak(km+1)-ak(km) + (bk(km+1)-bk(km))*p_ref )
    do i=ifirst, ilast
       if(.not. delp(i,j,km) >= dpmin) then ! catches NaN
 !      if(delp(i,j,km) < dpmin) then
diff --git a/model/fv_arrays.F90 b/model/fv_arrays.F90
index 370d02d..21d3180 100644
--- a/model/fv_arrays.F90
+++ b/model/fv_arrays.F90
@@ -58,6 +58,12 @@ module fv_arrays_mod
      real  sphum, liq_wat, ice_wat       ! GFDL physics
      real  rainwat, snowwat, graupel
 
+#ifdef MARS_GCM
+     integer ::  id_t05
+     integer ::  id_tdust, id_sfc_dust
+     integer ::  id_t5mb, id_u5mb, id_v5mb
+#endif MARS_GCM
+
      real :: efx(max_step), efx_sum, efx_nest(max_step), efx_sum_nest, mtq(max_step), mtq_sum
      integer :: steps
 
@@ -624,6 +630,13 @@ module fv_arrays_mod
                                     !< conditions, instead of nudging the temperature back to the initial value.
                                     !< Nudging delz is simpler (faster), doesn’t require consideration of the
                                     !< virtual temperature effect, and may be more stable. .false.by default.
+
+#ifdef MARS_GCM
+   real    :: p_ref = 7.25E2
+   real    :: reference_sfc_pres = 7.25E2
+   real    :: sponge_damp=   1.0
+   real    :: dry_mass = 7.25E2
+#else
    real    :: p_ref = 1.E5   !< Surface pressure used to construct a horizontally-uniform reference
                              !< vertical pressure profile, used in some simple physics packages
                              !< in the solo_core and in the Rayleigh damping. This should not be
@@ -634,6 +647,7 @@ module fv_arrays_mod
                                  !< measured in the globally-averaged surface pressure (Pascals) by adding
                                  !< or removing mass from the lowest layer of the atmosphere as needed.
                                  !< The default value is 98290. (Pa).
+#endif
    integer :: nt_prog = 0
    integer :: nt_phys = 0
    real    :: tau_h2o = 0.  !< Time-scale (days) for simple methane chemistry to act as
@@ -703,7 +717,7 @@ module fv_arrays_mod
    logical :: fill_gfs = .true. ! default behavior
    logical :: check_negative = .false.   !< Whether to print the most negativ global value of microphysical tracers.
    logical :: non_ortho = .true.
-   logical :: moist_phys = .true.     !< Run with moist physics
+   logical :: moist_phys = .false.     !< Run with moist physics
    logical :: do_Held_Suarez = .false.   !< Whether to use Held-Suarez forcing. Requires adiabatic
                                          !< to be false. The default is .false.; this option has no
                                          !< effect if not running solo_core.
diff --git a/model/fv_control.F90 b/model/fv_control.F90
index 6766da8..e3479ab 100644
--- a/model/fv_control.F90
+++ b/model/fv_control.F90
@@ -64,6 +64,9 @@ module fv_control_mod
                                   mpp_max
    use fv_diagnostics_mod,  only: fv_diag_init_gn
    use coarse_grained_restart_files_mod, only: deallocate_coarse_restart_type
+#ifdef MARS_GCM
+   use init_hydro_mod,      only: isotemp, do_isothermal  !Urata 2/6/2019
+#endif
 
    implicit none
    private
@@ -213,8 +216,15 @@ module fv_control_mod
 
      integer , pointer :: na_init
      logical , pointer :: nudge_dz
+#ifdef MARS_GCM
      real    , pointer :: p_ref
+     real    , pointer :: reference_sfc_pres
+     real    , pointer :: sponge_damp
      real    , pointer :: dry_mass
+#else
+     real    , pointer :: p_ref
+     real    , pointer :: dry_mass
+#endif
      integer , pointer :: nt_prog
      integer , pointer :: nt_phys
      real    , pointer :: tau_h2o
@@ -755,6 +765,10 @@ module fv_control_mod
        sg_cutoff                     => Atm%flagstruct%sg_cutoff
        na_init                       => Atm%flagstruct%na_init
        nudge_dz                      => Atm%flagstruct%nudge_dz
+#ifdef MARS_GCM
+       reference_sfc_pres            => Atm%flagstruct%reference_sfc_pres
+       sponge_damp                   => Atm%flagstruct%sponge_damp
+#endif
        p_ref                         => Atm%flagstruct%p_ref
        dry_mass                      => Atm%flagstruct%dry_mass
        nt_prog                       => Atm%flagstruct%nt_prog
@@ -929,6 +943,9 @@ module fv_control_mod
             tau, tau_h2o, rf_cutoff, nf_omega, hydrostatic, fv_sg_adj, sg_cutoff, breed_vortex_inline,  &
             na_init, nudge_dz, hybrid_z, Make_NH, n_zs_filter, nord_zs_filter, full_zs_filter, reset_eta,         &
             pnats, dnats, dnrts, a2b_ord, remap_t, p_ref, d2_bg_k1, d2_bg_k2,  &
+#ifdef MARS_GCM
+            sponge_damp, reference_sfc_pres, moist_phys,                    &
+#endif
             c2l_ord, dx_const, dy_const, umax, deglat,      &
             deglon_start, deglon_stop, deglat_start, deglat_stop, &
             phys_hydrostatic, use_hydro_pressure, make_hybrid_z, old_divg_damp, add_noise, &
@@ -941,13 +958,34 @@ module fv_control_mod
             write_only_coarse_intermediate_restarts, &
             write_coarse_agrid_vel_rst, write_coarse_dgrid_vel_rst
 
+#ifdef MARS_GCM
+!  new namelist for mars atmosphere init Urata 2/6/2019
+       namelist /mars_iso_nml/isotemp,do_isothermal
+
+       isotemp = 170.  !was 200 originally
+       do_isothermal = .true.
+#endif
 
+#ifdef INTERNAL_FILE_NML
        ! Read FVCORE namelist
        read (input_nml_file,fv_core_nml,iostat=ios)
        ierr = check_nml_error(ios,'fv_core_nml')
        ! Reset input_file_nml to default behavior (CHECK do we still need this???)
        !call read_input_nml
- 
+       ! Read Mars atmosphere init conds
+       read (input_nml_file,mars_iso_nml,iostat=ios)
+       ierr = check_nml_error(ios,'mars_iso_nml')
+#else
+       f_unit = open_namelist_file(Atm%nml_filename)
+       ! Read FVCORE namelist
+       read (f_unit,fv_core_nml,iostat=ios)
+       ierr = check_nml_error(ios,'fv_core_nml')
+       ! Read Mars atmosphere init conds
+       rewind (f_unit)
+       read (f_unit,mars_iso_nml,iostat=ios)
+       ierr = check_nml_error(ios,'mars_iso_nml')
+       call close_file(f_unit)
+#endif
        call write_version_number ( 'FV_CONTROL_MOD', version )
        unit = stdlog()
        write(unit, nml=fv_core_nml)
@@ -967,6 +1005,9 @@ module fv_control_mod
        ! Define n_split if not in namelist
        if (ntiles==6) then
           dimx = 4.0*(npx-1)
+#ifdef MARS_GCM
+          ns0 = 8
+#else
           if ( hydrostatic ) then
              if ( npx >= 120 ) ns0 = 6
           else
@@ -978,6 +1019,7 @@ module fv_control_mod
                 ns0 = 8
              endif
           endif
+#endif
        else
           dimx = max ( npx, 2*(npy-1) )
        endif
diff --git a/model/fv_grid_utils.F90 b/model/fv_grid_utils.F90
index 9e15085..df044da 100644
--- a/model/fv_grid_utils.F90
+++ b/model/fv_grid_utils.F90
@@ -192,7 +192,11 @@
       elseif ( .not. Atm%flagstruct%hybrid_z ) then
 ! Initialize (ak,bk) for cold start; overwritten with restart file
            if (.not. Atm%flagstruct%external_eta) then
+#ifndef MARS_GCM
               call set_eta(npz, Atm%ks, Atm%ptop, Atm%ak, Atm%bk, Atm%flagstruct%npz_type)
+#else
+              call set_eta(npz, Atm%ks, Atm%ptop, Atm%ak, Atm%bk, Atm%flagstruct%p_ref)
+#endif
               if ( is_master() ) then
                  write(*,*) 'Grid_init', npz, Atm%ks, Atm%ptop
                  tmp1 = Atm%ak(Atm%ks+1)
diff --git a/model/fv_mapz.F90 b/model/fv_mapz.F90
index e89b48d..ad0b9c0 100644
--- a/model/fv_mapz.F90
+++ b/model/fv_mapz.F90
@@ -33,7 +33,9 @@ module fv_mapz_mod
   use fv_arrays_mod,     only: fv_grid_type, fv_grid_bounds_type, R_GRID, inline_mp_type
   use fv_timing_mod,     only: timing_on, timing_off
   use fv_mp_mod,         only: is_master, mp_reduce_min, mp_reduce_max
+#ifndef MARS_GCM
   use fv_cmp_mod,        only: qs_init, fv_sat_adj
+#endif
 
   implicit none
   real, parameter:: consv_min = 0.001   ! below which no correction applies
@@ -172,6 +174,7 @@ contains
        cld_amt = get_tracer_index (MODEL_ATMOS, 'cld_amt')
        ccn_cm3 = get_tracer_index (MODEL_ATMOS, 'ccn_cm3')
 
+#ifndef MARS_GCM
        if ( do_adiabatic_init .or. do_sat_adj ) then
             fast_mp_consv = (.not.do_adiabatic_init) .and. consv>consv_min
             do k=1,km
@@ -180,6 +183,7 @@ contains
             enddo
             call qs_init(kmp)
        endif
+#endif
 
 !$OMP parallel do default(none) shared(is,ie,js,je,km,pe,ptop,kord_tm,hydrostatic, &
 !$OMP                                  pt,pk,rg,peln,q,nwat,liq_wat,rainwat,ice_wat,snowwat,    &
@@ -648,6 +652,7 @@ if( last_step .and. (.not.do_adiabatic_init)  ) then
   endif        ! end consv check
 endif        ! end last_step check
 
+#ifndef MARS_GCM
 ! Note: pt at this stage is T_v
 ! if ( (.not.do_adiabatic_init) .and. do_sat_adj ) then
   if (do_adiabatic_init .or. do_sat_adj) then
@@ -692,6 +697,7 @@ endif        ! end last_step check
 
                                            call timing_off('sat_adj2')
   endif   ! do_sat_adj
+#endif
 
   if ( last_step ) then
        ! Output temperature if last_step
diff --git a/model/fv_sg.F90 b/model/fv_sg.F90
index f1f5ee4..b82a3de 100644
--- a/model/fv_sg.F90
+++ b/model/fv_sg.F90
@@ -26,21 +26,22 @@ module fv_sg_mod
   use constants_mod,      only: rdgas, rvgas, cp_air, cp_vapor, hlv, hlf, kappa, grav
   use tracer_manager_mod, only: get_tracer_index
   use field_manager_mod,  only: MODEL_ATMOS
-  use gfdl_cloud_microphys_mod, only: wqs1, wqs2, wqsat2_moist
+#ifndef MARS_GCM
+  use lin_cld_microphys_mod, only: wqs2, wqsat2_moist
+#endif
   use fv_mp_mod,          only: mp_reduce_min, is_master
-  use mpp_mod,            only: mpp_pe
 
 implicit none
 private
 
-public  fv_subgrid_z, qsmith, neg_adj3
+public  fv_subgrid_z, qsmith, neg_adj3, fv_dry_conv
 
   real, parameter:: esl = 0.621971831
   real, parameter:: tice = 273.16
-  real, parameter:: c_ice = 2106.  ! Emanuel table, page 566
-! real, parameter:: c_ice = 1972.  !  -15 C
-! real, parameter:: c_liq = 4.1855e+3    ! GFS
-  real, parameter:: c_liq = 4218.        ! ECMWF-IFS
+! real, parameter:: c_ice = 2106.  ! Emanuel table, page 566
+  real, parameter:: c_ice = 1972.  !  -15 C
+  real, parameter:: c_liq = 4.1855e+3    ! GFS
+! real, parameter:: c_liq = 4218.        ! ECMWF-IFS
   real, parameter:: cv_vap = cp_vapor - rvgas  ! 1384.5
   real, parameter:: c_con = c_ice
 
@@ -82,7 +83,7 @@ contains
       real, intent(in)::   pe(is-1:ie+1,km+1,js-1:je+1)
       real, intent(in):: peln(is  :ie,  km+1,js  :je)
       real, intent(in):: delp(isd:ied,jsd:jed,km)      ! Delta p at each model level
-      real, intent(in):: delz(is:,js:,1:)      ! Delta z at each model level
+      real, intent(in):: delz(isd:,jsd:,1:)      ! Delta z at each model level
       real, intent(in)::  pkz(is:ie,js:je,km)
       logical, intent(in)::  hydrostatic
       integer, intent(in), optional:: k_bot
@@ -311,7 +312,7 @@ contains
 ! top layer unphysically warm
                ri = 0.
             elseif ( tv2<t_min ) then
-               ri = min(ri, 0.1)
+               ri = min(ri, 0.2)
             endif
 ! Adjustment for K-H instability:
 ! Compute equivalent mass flux: mc
@@ -509,7 +510,7 @@ contains
       real, intent(in)::   pe(is-1:ie+1,km+1,js-1:je+1)
       real, intent(in):: peln(is  :ie,  km+1,js  :je)
       real, intent(in):: delp(isd:ied,jsd:jed,km)      ! Delta p at each model level
-      real, intent(in):: delz(is:,js:,1:)      ! Delta z at each model level
+      real, intent(in):: delz(isd:,jsd:,1:)      ! Delta z at each model level
       real, intent(in)::  pkz(is:ie,js:je,km)
       logical, intent(in)::  hydrostatic
    integer, intent(in), optional:: k_bot
@@ -882,7 +883,7 @@ contains
 !----------------------
 ! Saturation adjustment
 !----------------------
-#ifndef GFS_PHYS
+#ifndef MARS_GCM
   if ( nwat > 5 ) then
     do k=1, kbot
       if ( hydrostatic ) then
@@ -1122,7 +1123,7 @@ contains
  integer, intent(in):: is, ie, js, je, ng, kbot
  logical, intent(in):: hydrostatic
  real, intent(in):: dp(is-ng:ie+ng,js-ng:je+ng,kbot)  ! total delp-p
- real, intent(in):: delz(is:,js:,1:)
+ real, intent(in):: delz(is-ng:,js-ng:,1:)
  real, intent(in):: peln(is:ie,kbot+1,js:je)           ! ln(pe)
  logical, intent(in), OPTIONAL :: check_negative
  real, intent(inout), dimension(is-ng:ie+ng,js-ng:je+ng,kbot)::    &
@@ -1301,7 +1302,7 @@ real, dimension(is:ie,js:je):: pt2, qv2, ql2, qi2, qs2, qr2, qg2, dp2, p2, icpk,
 !******************************************
 ! Fast moist physics: Saturation adjustment
 !******************************************
-#ifndef GFS_PHYS
+#ifndef MARS_GCM
  if ( sat_adj ) then
 
    do j=js, je
@@ -1465,21 +1466,8 @@ real, dimension(is:ie,js:je):: pt2, qv2, ql2, qi2, qs2, qr2, qg2, dp2, p2, icpk,
         qa(i,j,kbot) = max(0., qa(i,j,kbot))
    enddo
  enddo
-
  endif
 
-  if ( present(check_negative) ) then
-  if ( check_negative ) then
-     call prt_negative('Temperature', pt, is, ie, js, je, ng, kbot, 165.)
-     call prt_negative('sphum',   qv, is, ie, js, je, ng, kbot, -1.e-8)
-     call prt_negative('liq_wat', ql, is, ie, js, je, ng, kbot, -1.e-7)
-     call prt_negative('rainwat', qr, is, ie, js, je, ng, kbot, -1.e-7)
-     call prt_negative('ice_wat', qi, is, ie, js, je, ng, kbot, -1.e-7)
-     call prt_negative('snowwat', qs, is, ie, js, je, ng, kbot, -1.e-7)
-     call prt_negative('graupel', qg, is, ie, js, je, ng, kbot, -1.e-7)
-  endif
-  endif
-
  end subroutine neg_adj3
 
  subroutine fillq(im, km, q, dp)
@@ -1531,9 +1519,6 @@ real, dimension(is:ie,js:je):: pt2, qv2, ql2, qi2, qs2, qr2, qg2, dp2, p2, icpk,
       do j=js,je
          do i=is,ie
             qmin = min(qmin, q(i,j,k))
-!!$            if (q(i,j,k) < threshold) then
-!!$               print*, mpp_pe(), " Negative found in ", trim(qname), i, j, k, q(i,j,k)
-!!$            endif
          enddo
       enddo
       enddo
@@ -1543,4 +1528,265 @@ real, dimension(is:ie,js:je):: pt2, qv2, ql2, qi2, qs2, qr2, qg2, dp2, p2, icpk,
  end subroutine prt_negative
 
 
+
+ subroutine fv_dry_conv( isd, ied, jsd, jed, is, ie, js, je, km, nq, dt,    &
+                         tau, delp, pe, peln, pkz, ta, qa, ua, va,  &
+                         hydrostatic, w, delz, u_dt, v_dt, t_dt, q_dt )
+! Dry convective adjustment-mixing
+!-------------------------------------------
+      integer, intent(in):: is, ie, js, je, km, nq
+      integer, intent(in):: isd, ied, jsd, jed
+      integer, intent(in):: tau         ! Relaxation time scale
+      real, intent(in):: dt             ! model time step
+      real, intent(in)::   pe(is-1:ie+1,km+1,js-1:je+1)
+      real, intent(in):: peln(is  :ie,  km+1,js  :je)
+      real, intent(in):: delp(isd:ied,jsd:jed,km)      ! Delta p at each model level
+      real, intent(in)::  pkz(is:ie,js:je,km)      ! Delta p at each model level
+      real, intent(in):: delz(isd:ied,jsd:jed,km)      ! Delta p at each model level
+      logical, intent(in)::  hydrostatic
+!
+      real, intent(inout):: ua(isd:ied,jsd:jed,km)
+      real, intent(inout):: va(isd:ied,jsd:jed,km)
+      real, intent(inout)::  w(isd:ied,jsd:jed,km)      ! Delta p at each model level
+      real, intent(inout):: ta(isd:ied,jsd:jed,km)      ! Temperature
+      real, intent(inout):: qa(isd:ied,jsd:jed,km,nq)   ! Specific humidity & tracers
+      real, intent(inout):: u_dt(isd:ied,jsd:jed,km)
+      real, intent(inout):: v_dt(isd:ied,jsd:jed,km)
+      real, intent(inout):: t_dt(is:ie,js:je,km)
+      real, intent(inout):: q_dt(is:ie,js:je,km,nq)
+!---------------------------Local variables-----------------------------
+      real, dimension(is:ie,km):: u0, v0, w0, t0, hd, te, gz, tvm, pm
+      real q0(is:ie,km,nq), qcon(is:ie,km)
+      real gzh(is:ie)
+      real ri, pt1, pt2, ratio, tv, cv
+      real qmix, h0, mc, fra, rk, rz, rcv, rdt
+      real qs1, qs2, lf, dh, dhs
+      integer i, j, k, kk, n, m, iq
+      real, parameter:: ustar2 = 1.E-2
+      integer :: sphum, liq_wat, rainwat, snowwat, graupel, ice_wat, cld_amt
+
+        rz = rvgas - rdgas          ! rz = zvir * rdgas
+        rk = cp_air/rdgas + 1.
+        cv = cp_air - rdgas
+       rcv = 1./cv
+
+      rdt = 1./ dt
+
+        sphum = get_tracer_index (MODEL_ATMOS, 'sphum')
+      liq_wat = get_tracer_index (MODEL_ATMOS, 'liq_wat')
+      ice_wat = get_tracer_index (MODEL_ATMOS, 'ice_wat')
+      cld_amt = get_tracer_index (MODEL_ATMOS, 'cld_amt')
+
+      if ( nq.ge.6 ) then
+           rainwat = get_tracer_index (MODEL_ATMOS, 'rainwat')
+           snowwat = get_tracer_index (MODEL_ATMOS, 'snowwat')
+           graupel = get_tracer_index (MODEL_ATMOS, 'graupel')
+      endif
+
+!------------------------------------------------------------------------
+! The nonhydrostatic pressure changes if there is heating (under constant
+! volume and mass is locally conserved).
+!------------------------------------------------------------------------
+   m = 3
+   fra = dt/real(tau)
+
+!$omp parallel do default(shared) private(kk, qcon, q0, t0, u0, v0, w0, h0, pm, gzh, tvm, tv, gz, hd, te, ratio, pt1, pt2, ri, mc)
+  do 1000 j=js,je
+
+    do iq=1, nq
+       do k=1,km
+          do i=is,ie
+             q0(i,k,iq) = qa(i,j,k,iq)
+          enddo
+       enddo
+    enddo
+
+    do k=1,km
+       do i=is,ie
+          t0(i,k) = ta(i,j,k)
+         tvm(i,k) = t0(i,k)*(1.+zvir*q0(i,k,sphum))
+          u0(i,k) = ua(i,j,k)
+          v0(i,k) = va(i,j,k)
+          pm(i,k) = delp(i,j,k)/(peln(i,k+1,j)-peln(i,k,j))
+       enddo
+    enddo
+
+    do i=is,ie
+       gzh(i) = 0.
+    enddo
+
+    if( hydrostatic ) then
+       do k=km, 1,-1
+          do i=is,ie
+                tv  = rdgas*tvm(i,k)
+            gz(i,k) = gzh(i) + tv*(1.-pe(i,k,j)/pm(i,k))
+            hd(i,k) = cp_air*tvm(i,k)+gz(i,k)+0.5*(u0(i,k)**2+v0(i,k)**2)
+             gzh(i) = gzh(i) + tv*(peln(i,k+1,j)-peln(i,k,j))
+          enddo
+       enddo
+    else
+       do k=km, 1, -1
+          do i=is,ie
+             w0(i,k) = w(i,j,k)
+             gz(i,k) = gzh(i)  - 0.5*grav*delz(i,j,k)
+                 tv  = gz(i,k) + 0.5*(u0(i,k)**2+v0(i,k)**2+w0(i,k)**2)
+             hd(i,k) = cp_air*tvm(i,k) + tv
+             te(i,k) =     cv*tvm(i,k) + tv
+              gzh(i) = gzh(i) - grav*delz(i,j,k)
+          enddo
+       enddo
+    endif
+
+   do n=1,m
+
+      ratio = real(n)/real(m)
+
+      do i=is,ie
+         gzh(i) = 0.
+      enddo
+
+! Compute total condensate
+
+      do k=km, 2, -1
+
+         do i=is,ie
+! Richardson number = g*delz * theta / ( del_theta * (del_u**2 + del_v**2) )
+if ( nq .le. 3 .or. zvir .lt. 1.e-3 ) then
+            qcon(i,k-1) = 0.
+            qcon(i,k) = 0.
+elseif ( nq .le. 5 ) then
+            qcon(i,k-1) = q0(i,k-1,liq_wat) + q0(i,k-1,ice_wat)
+            qcon(i,k  ) = q0(i,k,  liq_wat) + q0(i,k,  ice_wat)
+else
+            qcon(i,k-1) = q0(i,k-1,liq_wat) + q0(i,k-1,ice_wat) + q0(i,k-1,snowwat) + q0(i,k-1,rainwat) + q0(i,k-1,graupel)
+            qcon(i,k) = q0(i,k,liq_wat) + q0(i,k,ice_wat) + q0(i,k,snowwat) + q0(i,k,rainwat) + q0(i,k,graupel)
+endif
+            pt1 = t0(i,k-1)/pkz(i,j,k-1)*(1.+zvir*q0(i,k-1,sphum)-qcon(i,k-1))
+            pt2 = t0(i,k  )/pkz(i,j,k  )*(1.+zvir*q0(i,k  ,sphum)-qcon(i,k))
+            ri = (gz(i,k-1)-gz(i,k))*(pt1-pt2)/( 0.5*(pt1+pt2)*        &
+                ((u0(i,k-1)-u0(i,k))**2+(v0(i,k-1)-v0(i,k))**2+ustar2) )
+! Dry convective adjustment for K-H instability:
+! Compute equivalent mass flux: mc
+            if ( ri < 1. ) then
+                 mc = ratio*(1.-max(0.0,ri)) ** 2
+                 mc = mc*delp(i,j,k-1)*delp(i,j,k)/(delp(i,j,k-1)+delp(i,j,k))
+                 do iq=1,nq
+                    h0 = mc*(q0(i,k,iq)-q0(i,k-1,iq))
+                    q0(i,k-1,iq) = q0(i,k-1,iq) + h0/delp(i,j,k-1)
+                    q0(i,k  ,iq) = q0(i,k  ,iq) - h0/delp(i,j,k  )
+                 enddo
+! u:
+                 h0 = mc*(u0(i,k)-u0(i,k-1))
+                 u0(i,k-1) = u0(i,k-1) + h0/delp(i,j,k-1)
+                 u0(i,k  ) = u0(i,k  ) - h0/delp(i,j,k  )
+! v:
+                 h0 = mc*(v0(i,k)-v0(i,k-1))
+                 v0(i,k-1) = v0(i,k-1) + h0/delp(i,j,k-1)
+                 v0(i,k  ) = v0(i,k  ) - h0/delp(i,j,k  )
+              if ( hydrostatic ) then
+                 h0 = mc*(hd(i,k)-hd(i,k-1))
+                 hd(i,k-1) = hd(i,k-1) + h0/delp(i,j,k-1)
+                 hd(i,k  ) = hd(i,k  ) - h0/delp(i,j,k  )
+              else
+! Total energy
+                        h0 = mc*(hd(i,k)-hd(i,k-1))
+                 te(i,k-1) = te(i,k-1) + h0/delp(i,j,k-1)
+                 te(i,k  ) = te(i,k  ) - h0/delp(i,j,k  )
+! w:
+                        h0 = mc*(w0(i,k)-w0(i,k-1))
+                 w0(i,k-1) = w0(i,k-1) + h0/delp(i,j,k-1)
+                 w0(i,k  ) = w0(i,k  ) - h0/delp(i,j,k  )
+              endif
+            endif
+         enddo
+
+!--------------
+! Retrive Temp:
+!--------------
+       if ( hydrostatic ) then
+         kk = k
+         do i=is,ie
+            t0(i,kk) = (hd(i,kk)-gzh(i)-0.5*(u0(i,kk)**2+v0(i,kk)**2))  &
+                     / ( rk - pe(i,kk,j)/pm(i,kk) )
+              gzh(i) = gzh(i) + t0(i,kk)*(peln(i,kk+1,j)-peln(i,kk,j))
+            t0(i,kk) = t0(i,kk) / ( rdgas + rz*q0(i,kk,sphum) )
+         enddo
+         kk = k-1
+         do i=is,ie
+            t0(i,kk) = (hd(i,kk)-gzh(i)-0.5*(u0(i,kk)**2+v0(i,kk)**2))  &
+                     / ((rk-pe(i,kk,j)/pm(i,kk))*(rdgas+rz*q0(i,kk,sphum)))
+         enddo
+       else
+! Non-hydrostatic under constant volume heating/cooling
+         do kk=k-1,k
+            do i=is,ie
+               tv = gz(i,kk) + 0.5*(u0(i,kk)**2+v0(i,kk)**2+w0(i,kk)**2)
+               tvm(i,kk) = rcv*(te(i,kk)- tv)
+                hd(i,kk) = cp_air*tvm(i,kk) + tv
+                t0(i,kk) = tvm(i,kk)/(1.+zvir*q0(i,kk,sphum))
+            enddo
+         enddo
+       endif
+      enddo   ! k-loop
+
+   enddo       ! n-loop
+
+
+!--------------------
+   if ( fra < 1. ) then
+      do k=1, km
+         do i=is,ie
+            t0(i,k) = ta(i,j,k) + (t0(i,k) - ta(i,j,k))*fra
+            u0(i,k) = ua(i,j,k) + (u0(i,k) - ua(i,j,k))*fra
+            v0(i,k) = va(i,j,k) + (v0(i,k) - va(i,j,k))*fra
+         enddo
+      enddo
+
+      if ( .not. hydrostatic ) then
+         do k=1,km
+            do i=is,ie
+               w0(i,k) = w(i,j,k) + (w0(i,k) - w(i,j,k))*fra
+            enddo
+         enddo
+      endif
+
+      do iq=1,nq
+         do k=1,km
+            do i=is,ie
+               q0(i,k,iq) = qa(i,j,k,iq) + (q0(i,k,iq) - qa(i,j,k,iq))*fra
+            enddo
+         enddo
+      enddo
+   endif
+!--------------------
+
+   do k=1,km
+      do i=is,ie
+         u_dt(i,j,k) = rdt*(u0(i,k) - ua(i,j,k))
+         v_dt(i,j,k) = rdt*(v0(i,k) - va(i,j,k))
+         t_dt(i,j,k) = 0.
+           ta(i,j,k) = t0(i,k)   ! *** temperature updated ***
+      enddo
+      do iq=1,nq
+         do i=is,ie
+            q_dt(i,j,k,iq) = rdt*(q0(i,k,iq)-qa(i,j,k,iq))
+         enddo
+      enddo
+   enddo
+
+   if ( .not. hydrostatic ) then
+      do k=1,km
+         do i=is,ie
+            w(i,j,k) = w0(i,k)   ! w updated
+         enddo
+      enddo
+   endif
+
+1000 continue
+
+
+ end subroutine fv_dry_conv
+
+
+
 end module fv_sg_mod
diff --git a/model/fv_update_phys.F90 b/model/fv_update_phys.F90
index d3672de..19f846f 100644
--- a/model/fv_update_phys.F90
+++ b/model/fv_update_phys.F90
@@ -274,6 +274,22 @@ module fv_update_phys_mod
 
        if (present(q_dt)) then
 
+#if defined(MARS_GCM) || defined(VENUS_GCM)
+!----------------
+! Update tracers:
+!----------------
+       do m=1,nq
+          if( m /= w_diff ) then
+          do j=js,je
+             do i=is,ie
+                q(i,j,k,m) = q(i,j,k,m) + dt*q_dt(i,j,k,m)
+             enddo
+          enddo
+          endif
+       enddo
+!        --------  Skip Methane chemistry:    flagstruct%tau_h2o>0.0   -------------
+
+#else
        if (flagstruct%tau_h2o<0.0 .and. pfull(k) < 100.E2 ) then
 ! Wipe the stratosphere clean:
 ! This should only be used for initialization from a bad model state
@@ -358,7 +374,7 @@ module fv_update_phys_mod
           endif
         enddo
       endif
-
+#endif
       endif ! present(q_dt)
 
       if ( hydrostatic ) then
diff --git a/tools/fv_diagnostics.F90 b/tools/fv_diagnostics.F90
index bcf0643..51f7c54 100644
--- a/tools/fv_diagnostics.F90
+++ b/tools/fv_diagnostics.F90
@@ -51,6 +51,30 @@ module fv_diagnostics_mod
 
  use fv_diag_column_mod, only: fv_diag_column_init, sounding_column, debug_column
 
+#ifdef MARS_GDIAGS
+#if defined(MARS_GCM)
+   use mars_physics_mod,  only:  do_mars_surface, do_bin_water_cycle, do_dust_source_sink, &
+                               gascol
+#endif
+
+ use initracer_mod, only: ndust_mass, ntrace_gas, gas_indx
+ use aerosol_util_mod, only: do_moment_micro
+
+#ifndef RELEASE
+ use dust_update_mod, only: sfc_dust_mass, tcol_mass, tcol_core, dust_surf_ini
+#endif
+
+#if defined(MARS_SURFACE)
+ use mars_surface_mod,     only:  sfc_snow, sfc_frost
+#ifndef RELEASE
+ use dust_source_mod,      only:  sfc_dust, odcol
+ use aerosol_mod,          only:  ndust_bins, nice_bins, nice_moms, aerosol_bins, &
+                                  dust_indx, ice_bin_indx, ice_mom_indx
+
+ use cloud_physics_mod,   only:  cldcol, wcol
+#endif
+#endif
+#endif MARS_GDIAGS
  implicit none
  private
 
@@ -113,6 +137,10 @@ module fv_diagnostics_mod
 
  real              :: vrange(2), vsrange(2), wrange(2), trange(2), slprange(2), rhrange(2)
 
+#ifdef MARS_GCM
+  integer ::  id_tkd, id_ukd, id_vkd, id_t5mb, id_u5mb, id_v5mb
+#endif
+
  ! integer :: id_d_grid_ucomp, id_d_grid_vcomp   ! D grid winds
  ! integer :: id_c_grid_ucomp, id_c_grid_vcomp   ! C grid winds
 
@@ -194,12 +222,21 @@ contains
     vrange = (/ -330.,  330. /)  ! winds
     wrange = (/ -100.,  100. /)  ! vertical wind
    rhrange = (/  -10.,  150. /)  ! RH
+
+#if defined(MARS_GCM)
+    slprange = (/0.,  100./)  ! sea-level-pressure
+    trange = (/  50., 360. /)  ! temperature
+#elif defined(VENUS_GCM)
+    trange = (/  100.,  900. /)  ! temperature
+    slprange = (/80.E3,  98.E3/)  ! sea-level-pressure
+#else
 #ifdef HIWPP
     trange = (/    5.,  350. /)  ! temperature
 #else
-    trange = (/  100.,  350. /)  ! temperature
+    trange = (/  100.,  400. /)  ! temperature
 #endif
     slprange = (/800.,  1200./)  ! sea-level-pressure
+#endif
 
     ginv = 1./GRAV
      if (Atm(1)%grid_number == 1) fv_time = Time
@@ -282,7 +319,7 @@ contains
          'vertical coordinate sigma value', 'none' )
 
     id_pk    = register_static_field ( "dynamics", 'pk', (/id_phalf/), &
-         'pressure part of the hybrid coordinate', 'pascal' )
+         'pressure part of the hybrid coordinate', 'Pa' )
 
     id_hyam    = register_static_field ( "dynamics", 'hyam', (/id_pfull/), &
          'vertical coordinate A value', '1E-5 Pa' )
@@ -1010,9 +1047,38 @@ contains
                 'Echo top ( <= 18.5 dBz )', 'm', missing_value=missing_value2)
        id_dbz_m10C = register_diag_field ( trim(field), 'm10C_reflectivity', axes(1:2), time, &
                 'Reflectivity at -10C level', 'm', missing_value=missing_value)
+#ifdef MARS_GCM
+!--------------------------
+! Extra Martian diagnostics:
+!--------------------------
+
+       idiag%id_t05 = register_diag_field ( trim(field), 't05', axes(1:2), Time,       &
+               '0.5-mb temperature', 'K', missing_value=missing_value )
+!!       idiag%id_sfc_dust = register_diag_field ( trim(field), 'sfc_dust', axes(1:2), Time,        &
+!!             'Total sfc dust', 'kg/m**2', missing_value=missing_value )
+!!        idiag%id_tdust = register_diag_field ( trim(field), 'odcol', axes(1:2), Time,        &
+!!             'Total dust column', 'kg/m**2', missing_value=missing_value )
+
+       id_tkd= register_diag_field( trim(field), 'tkd', axes(1:2), Time, &
+            'Lowest_level temperatures', 'K', missing_value=missing_value )
+
+       id_ukd= register_diag_field( trim(field), 'ukd', axes(1:2), Time, &
+            'Lowest_level U velocity', 'm/s', missing_value=missing_value )
+
+       id_vkd= register_diag_field( trim(field), 'vkd', axes(1:2), Time, &
+            'Lowest_level V velocity', 'm/s', missing_value=missing_value )
+
+       idiag%id_t5mb = register_diag_field ( trim(field), 't5mb', axes(1:2), Time,       &
+               '5.0-mb temperature', 'K', missing_value=missing_value )
+       idiag%id_u5mb = register_diag_field ( trim(field), 'u5mb', axes(1:2), Time,       &
+               '5.0-mb U velocity', 'm/s', missing_value=missing_value )
+       idiag%id_v5mb = register_diag_field ( trim(field), 'v5mb', axes(1:2), Time,       &
+               '5.0-mb V velocity', 'm/s', missing_value=missing_value )
+
+#endif MARS_GCM
 
 !--------------------------
-! Extra surface diagnostics:
+! Extra surface diagnistics:
 !--------------------------
 ! Surface (lowest layer) vorticity: for tropical cyclones diag.
        id_vorts = register_diag_field ( trim(field), 'vorts', axes(1:2), Time,       &
@@ -1421,6 +1487,11 @@ contains
     real :: tmp2, pvsum, e2, einf, qm, mm, maxdbz, allmax, rgrav, cv_vapor
     real, allocatable :: cvm(:)
     integer :: Cl, Cl2, k1, k2
+#ifdef MARS_GCM
+    real  ::   atm_mass,  sfc_mass, atm_cloud
+    real  ::   tsfc_dust_bin, tcol_dust_bin
+    real  ::   gdust_mass_sfc, gdust_mass_col, gdust_mass_cor
+#endif
 
     !!! CLEANUP: does it really make sense to have this routine loop over Atm% anymore? We assume n=1 below anyway
 
@@ -1464,7 +1535,14 @@ contains
     fv_time = Time
 
     if ( m_calendar ) then
+#if defined(MARS_GCM) || defined(VENUS_GCM)
+         call get_time (fv_time, seconds,  days)
+         mn= 0
+         hr= 0
+         mon= 0
+#else
          call get_date(fv_time, yr, mon, dd, hr, mn, seconds)
+#endif
          if( print_freq == 0 ) then
                  prt_minmax = .false.
          elseif( print_freq < 0 ) then
@@ -1499,11 +1577,15 @@ contains
      endif
 
      if(prt_minmax) then
+#if defined(MARS_GCM) || defined(VENUS_GCM)
+        if(master) write(*,*) 'Sol =', Days, '   sec =', seconds
+#else
          if ( m_calendar ) then
               if(master) write(*,*) yr, mon, dd, hr, mn, seconds
          else
               if(master) write(*,*) Days, seconds
          endif
+#endif
      endif
 
     allocate ( a2(isc:iec,jsc:jec) )
@@ -1590,6 +1672,73 @@ contains
 !       call prt_maxmin('Top: TA', Atm(n)%pt(isc:iec,jsc:jec,  1), isc, iec, jsc, jec, 0, 1, 1.)
 !       call prt_maxmin('Bot: TA', Atm(n)%pt(isc:iec,jsc:jec,npz), isc, iec, jsc, jec, 0, 1, 1.)
         call prt_maxmin('OM', Atm(n)%omga, isc, iec, jsc, jec, ngc, npz, 1.)
+#endif
+
+#if defined(MARS_GCM) && defined(MARS_SURFACE)
+#ifdef MARS_GDIAGS
+
+        atm_mass  = g_sum( Atm(n)%domain, Atm(n)%ps(isc:iec,jsc:jec), isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        if(master) write(*,*) 'Atmospheric CO2 (Pa)', trim(gn), ' =', atm_mass
+
+      if( do_mars_surface ) then
+        sfc_mass  = g_sum( Atm(n)%domain,                    sfc_snow,isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        sfc_mass= sfc_mass*grav   !   Conversion to pressure units
+
+        if(master) write(*,*) 'CO2 sfc frost   (Pa)', trim(gn), ' =', sfc_mass
+        if(master) write(*,*) 'Total CO2 Inventory ', trim(gn), ' =', (atm_mass+sfc_mass)
+     endif
+
+    if (ntrace_gas .gt. 0) then
+       do k=1,ntrace_gas
+        itrac= gas_indx(k)
+        call get_tracer_names(MODEL_ATMOS, itrac, tname)
+        atm_mass = g_sum( Atm(n)%domain, gascol(:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        if(master) write(*,*) 'Total ',trim(tname),' gas mass: = ',atm_mass
+       enddo
+    endif
+#ifndef RELEASE
+    if( do_bin_water_cycle ) then
+        sfc_mass  = g_sum( Atm(n)%domain, sfc_frost, isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        atm_mass  = g_sum( Atm(n)%domain,      wcol, isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        atm_cloud = g_sum( Atm(n)%domain,    cldcol, isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        sfc_mass= sfc_mass - 3.7   !  Arbitrary offset
+
+        if(master) write(*,*) 'Atmospheric H2o vapor (kg/m**2)', trim(gn), ' =', atm_mass
+        if(master) write(*,*) 'Atmospheric H2o cloud (kg/m**2)', trim(gn), ' =', atm_cloud
+        if(master) write(*,*) 'Total Atmospheric H2o', trim(gn), ' ', atm_cloud + atm_mass
+
+        if(master) write(*,*) 'H2O surface frost (kg/m**2)', trim(gn), ' ==', sfc_mass
+        if(master) write(*,*) 'Total H2O inventory', trim(gn), ' =', atm_mass+sfc_mass+atm_cloud
+    endif
+
+    if( do_dust_source_sink ) then
+
+       do k= 1, ndust_bins
+        tsfc_dust_bin  = g_sum( Atm(n)%domain, sfc_dust(:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        tcol_dust_bin  = g_sum( Atm(n)%domain, odcol   (:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        if(master) write(*,*) 'Aerosol balance for dust bin ',  k
+        if(master) write(*,*) 'Surface dust inventory (kg/m**2):  dust bin ', k, '  ', trim(gn), ' =', tsfc_dust_bin - 30.0
+        if(master) write(*,*) 'Atmospheric dust (kg/m**2): dust bin ', k, '  ', trim(gn), ' =', tcol_dust_bin
+        if(master) write(*,*) 'Total dust inventory: dust bin ', k, '  ', trim(gn), ' ', tsfc_dust_bin - 30.0 + tcol_dust_bin
+       enddo
+    endif
+
+    if( do_moment_micro ) then
+       do k= 1, ndust_mass
+        gdust_mass_sfc = g_sum( Atm(n)%domain, sfc_dust_mass(:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        gdust_mass_col = g_sum( Atm(n)%domain, tcol_mass(:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        gdust_mass_cor = g_sum( Atm(n)%domain, tcol_core(:,:,k),isc, iec, jsc, jec, ngc, Atm(n)%gridstruct%area,mode=1)
+        if(master) write(*,*) 'Aerosol balance for dust micro tracer ',  k
+        if(master) write(*,*) 'Srf dust: ', k, '  ', trim(gn), ' =', gdust_mass_sfc - dust_surf_ini
+        if(master) write(*,*) 'Atm dust: ', k, '  ', trim(gn), ' =', gdust_mass_col + gdust_mass_cor
+        if(master) write(*,*) 'Tot dust: ', k, '  ', trim(gn), ' =', gdust_mass_sfc - dust_surf_ini + gdust_mass_col + gdust_mass_cor
+
+       enddo
+     endif
+#endif
+
+#endif MARS_GDIAGS
+
 #endif
 
     elseif ( Atm(n)%flagstruct%range_warn ) then
@@ -2144,7 +2293,7 @@ contains
 
           allocate ( wz(isc:iec,jsc:jec,npz+1) )
           call get_height_field(isc, iec, jsc, jec, ngc, npz, Atm(n)%flagstruct%hydrostatic, Atm(n)%delz,  &
-                                wz, Atm(n)%pt, Atm(n)%q, Atm(n)%peln, zvir)
+                                wz, Atm(n)%pt, Atm(n)%q, Atm(n)%peln, zvir, Atm(n)%flagstruct%moist_phys)
           if( prt_minmax )   &
           call prt_mxm('ZTOP',wz(isc:iec,jsc:jec,1), isc, iec, jsc, jec, 0, 1, 1.E-3, Atm(n)%gridstruct%area_64, Atm(n)%domain)
 !         call prt_maxmin('ZTOP', wz(isc:iec,jsc:jec,1), isc, iec, jsc, jec, 0, 1, 1.E-3)
@@ -2385,7 +2534,7 @@ contains
        if (.not. allocated(wz)) allocate ( wz(isc:iec,jsc:jec,npz+1) )
 
        call get_height_field(isc, iec, jsc, jec, ngc, npz, Atm(n)%flagstruct%hydrostatic, Atm(n)%delz,  &
-                             wz, Atm(n)%pt, Atm(n)%q, Atm(n)%peln, zvir)
+                             wz, Atm(n)%pt, Atm(n)%q, Atm(n)%peln, zvir, Atm(n)%flagstruct%moist_phys)
 
        if ( do_cs_intp ) then  ! log(pe) as the coordinaite for temp re-construction
           if(.not. allocated (a3) ) allocate( a3(isc:iec,jsc:jec,nplev) )
@@ -2470,9 +2619,50 @@ contains
           endif
        endif
 
-       if (id_ts > 0) used = send_data(id_ts, Atm(n)%ts(isc:iec,jsc:jec), Time)
+#ifdef MARS_GCM
+       if ( idiag%id_t05>0 ) then
+            call interpolate_vertical(isc, iec, jsc, jec, npz,   &
+                                      0.5e2, Atm(n)%peln, Atm(n)%pt(isc:iec,jsc:jec,:), a2)
+            used=send_data(idiag%id_t05, a2, Time)
+       endif
+       if ( idiag%id_t5mb>0 ) then
+            call interpolate_vertical(isc, iec, jsc, jec, npz,   &
+                                      5.0e2, Atm(n)%peln, Atm(n)%pt(isc:iec,jsc:jec,:), a2)
+            used=send_data(idiag%id_t5mb, a2, Time)
+       endif
+       if ( idiag%id_u5mb>0 ) then
+            call interpolate_vertical(isc, iec, jsc, jec, npz,   &
+                                      5.0e2, Atm(n)%peln, Atm(n)%ua(isc:iec,jsc:jec,:), a2)
+            used=send_data(idiag%id_u5mb, a2, Time)
+       endif
+       if ( idiag%id_v5mb>0 ) then
+            call interpolate_vertical(isc, iec, jsc, jec, npz,   &
+                                      5.0e2, Atm(n)%peln, Atm(n)%va(isc:iec,jsc:jec,:), a2)
+            used=send_data(idiag%id_v5mb, a2, Time)
+       endif
+
+       if( id_tkd > 0 )  used= send_data( id_tkd, ATm(n)%pt(isc:iec,jsc:jec,npz), Time )
+       if( id_ukd > 0 )  used= send_data( id_ukd, ATm(n)%ua(isc:iec,jsc:jec,npz), Time )
+       if( id_vkd > 0 )  used= send_data( id_vkd, ATm(n)%va(isc:iec,jsc:jec,npz), Time )
 
+#ifdef MARS_GDIAGS
+       if (do_bin_water_cycle) then
        if ( id_tq>0 ) then
+          itrac= get_tracer_index (MODEL_ATMOS, 'h2o_vapor')
+          a2 = 0.
+          do k=1,npz
+          do j=jsc,jec
+             do i=isc,iec
+                a2(i,j) = a2(i,j) + Atm(n)%q(i,j,k,itrac)*Atm(n)%delp(i,j,k)
+             enddo
+          enddo
+          enddo
+          used = send_data(id_tq, a2*ginv, Time)
+       endif
+       endif
+#endif
+#else
+       if ( idiag%id_tq>0 ) then
           nwater = Atm(1)%flagstruct%nwat
           a2 = 0.
           do k=1,npz
@@ -2485,6 +2675,8 @@ contains
           enddo
           used = send_data(id_tq, a2*ginv, Time)
        endif
+#endif MARS_GCM
+
 #ifdef HIWPP
        Cl  = get_tracer_index (MODEL_ATMOS, 'Cl')
        Cl2 = get_tracer_index (MODEL_ATMOS, 'Cl2')
@@ -3843,21 +4035,28 @@ contains
  end subroutine get_vorticity
 
 
- subroutine get_height_field(is, ie, js, je, ng, km, hydrostatic, delz, wz, pt, q, peln, zvir)
+ subroutine get_height_field(is, ie, js, je, ng, km, hydrostatic, delz, wz, pt, q, peln, zvir, moist_phys)
   integer, intent(in):: is, ie, js, je, km, ng
   real, intent(in):: peln(is:ie,km+1,js:je)
   real, intent(in):: pt(is-ng:ie+ng,js-ng:je+ng,km)
   real, intent(in)::  q(is-ng:ie+ng,js-ng:je+ng,km,*) ! water vapor
   real, intent(in):: delz(is:,js:,1:)
   real, intent(in):: zvir
-  logical, intent(in):: hydrostatic
+  logical, intent(in):: hydrostatic, moist_phys
   real, intent(out):: wz(is:ie,js:je,km+1)
 !
   integer i,j,k
-  real gg
+  real gg,vt_fac(is-ng:ie+ng,js-ng:je+ng,km)
 
       gg  = rdgas * ginv
 
+
+      if (moist_phys) then
+         vt_fac = (1.+zvir*q(:,:,:,sphum))
+      else
+         vt_fac = 1.
+      endif
+
       do j=js,je
          do i=is,ie
             wz(i,j,km+1) = zsurf(i,j)
@@ -3865,7 +4064,7 @@ contains
       if (hydrostatic ) then
          do k=km,1,-1
             do i=is,ie
-               wz(i,j,k) = wz(i,j,k+1) + gg*pt(i,j,k)*(1.+zvir*q(i,j,k,sphum))  &
+               wz(i,j,k) = wz(i,j,k+1) + gg*pt(i,j,k)*vt_fac(i,j,k)  &
                           *(peln(i,k+1,j)-peln(i,k,j))
             enddo
          enddo
@@ -4105,6 +4304,19 @@ contains
  real psmo, totw, psdry
  integer k, n, kstrat
 
+#if defined(MARS_GCM) || defined(VENUS_GCM)
+ psmo = g_sum(domain, ps(is:ie,js:je), is, ie, js, je, n_g, area, 1)
+ totw  = 0.0
+ psdry = psmo - totw
+ if ( nwat > 0 ) then
+    qtot(:)= 0.0
+ endif
+
+ if( master ) then
+     write(*,*) 'Total surface pressure (Pa)', trim(gn), ' = ',  psmo
+!!!     write(*,*) 'mean dry surface pressure = ',    0.01*psdry
+  endif
+#else
 !Needed when calling prt_mass in fv_restart?
     sphum   = get_tracer_index (MODEL_ATMOS, 'sphum')
     liq_wat = get_tracer_index (MODEL_ATMOS, 'liq_wat')
@@ -4187,6 +4399,8 @@ contains
      endif
   endif
 
+#endif MARS_GCM
+
  end subroutine prt_mass
 
 
@@ -5525,8 +5739,8 @@ end subroutine eqv_pot
 !   Ferrier-Aligo has an option for fixed slope (rather than fixed intercept).
 !   Thompson presumably is an extension of Reisner MP.
 
-   use gfdl_cloud_microphys_mod, only : do_hail, rhor, rhos, rhog, rhoh, rnzr, rnzs, rnzg, rnzh
-   use gfdl_mp_mod, only: do_hail_inline => do_hail ! assuming same densities and numbers in both inline and traditional GFDL MP
+!   use gfdl_cloud_microphys_mod, only : do_hail, rhor, rhos, rhog, rhoh, rnzr, rnzs, rnzg, rnzh
+!   use gfdl_mp_mod, only: do_hail_inline => do_hail ! assuming same densities and numbers in both inline and traditional GFDL MP
    implicit none
 
    type(fv_grid_bounds_type), intent(IN) :: bd
@@ -5541,6 +5755,8 @@ end subroutine eqv_pot
    real,    intent(IN) :: zvir
    real,    intent(OUT) :: allmax
 
+#ifndef MARS_GCM
+
    !Parameters for constant intercepts (in0[rsg] = .false.)
    !Using GFDL MP values
    real(kind=R_GRID), parameter:: vconr = 2503.23638966667
@@ -5668,7 +5884,7 @@ end subroutine eqv_pot
          allmax = max(maxdbz(i,j), allmax)
       enddo
    enddo
-
+#endif
  end subroutine dbzcalc
 
  subroutine max_vorticity_hy1(is, ie, js, je, km, vort, maxvorthy1)
diff --git a/tools/fv_eta.F90 b/tools/fv_eta.F90
index 2aee5e0..c8a72f2 100644
--- a/tools/fv_eta.F90
+++ b/tools/fv_eta.F90
@@ -259,6 +259,131 @@ module fv_eta_mod
  end subroutine set_eta
 
 
+#elif defined(MARS_GCM) || defined(VENUS_GCM)
+
+
+ subroutine set_eta(km, ks, ptop, ak, bk, p_ref)
+#ifdef MARS_GCM
+#include <fv_eta_mars.h>
+#endif MARS_GCM
+#ifdef VENUS_GCM
+#include <fv_eta_venus.h>
+#endif VENUS_GCM
+
+      integer,  intent(in)::  km           ! vertical dimension
+
+      integer,  intent(out):: ks           ! number of pure p layers
+      real, intent(out):: ak(km+1)
+      real, intent(out):: bk(km+1)
+      real, intent(out):: ptop         ! model top (Pa)
+      real, intent(in):: p_ref
+! local
+
+
+#if defined(MARS_GCM)
+      real:: p0= 6.0E2
+      real:: pc= 1.0e-3
+#elif defined(VENUS_GCM)
+      real:: p0= 92.E5
+      real:: pc= 20.E5
+#endif
+
+      real pt, pint, lnpe, dlnp
+      real press(km+1), pt1(km)
+      integer  k
+
+
+
+! Definition: press(i,j,k) = ak(k) + bk(k) * ps(i,j)
+
+
+
+      select case (km)
+
+#ifdef MARS_GCM
+!------
+! Standard Grids for Mars [14July2022 ASB]
+
+       case (56)
+          ks =10
+          do k=1,km+1
+            ak(k) = a56(k)
+            bk(k) = b56(k)
+          enddo
+
+!------
+        case (24)
+            ks = 0
+            do k=1,km+1
+              ak(k) = a24(k)
+              bk(k) = b24(k)
+            enddo
+
+       case (30)
+          ks = 4
+          do k=1,km+1
+            ak(k) = a30(k)
+            bk(k) = b30(k)
+          enddo
+
+       case (37)
+          ks = 9
+          do k=1,km+1
+            ak(k) = a37(k)
+            bk(k) = b37(k)
+          enddo
+#endif MARS_GCM
+
+#ifdef VENUS_GCM
+       case (50)
+          ks = 28
+          do k=1,km+1
+            ak(k) = a50(k) * 92.E5
+            bk(k) = b50(k)
+          enddo
+       if ( is_master() ) then
+            write(*,*) 'Venus pressure levels'
+               do k=1,km+1
+                 write(*,*) k, ak(k), bk(k)
+               enddo
+       endif
+#endif VENUS_GCM
+
+        case default
+!----------------------------------------------------------------
+! Sigma-coordinate with uniform spacing in sigma and ptop = 1 Pa
+!----------------------------------------------------------------
+         pt = 1.
+! One pressure layer
+         ks = 1
+!        pint = pt + 0.5*1.E5/real(km)     ! SJL: 20120327
+         pint = pt + 1.E5/real(km)
+
+         ak(1) = pt
+         bk(1) = 0.
+         ak(2) = pint
+         bk(2) = 0.
+
+          do k=3,km+1
+             bk(k) = real(k-2) / real(km-1)
+             ak(k) = pint - bk(k)*pint
+          enddo
+          ak(km+1) = 0.
+          bk(km+1) = 1.
+      end select
+
+#ifdef MARS_GCM
+!rjw              Adjust the ak values for other pressure levels.
+   DO k=1,km+1
+       ak(k) = ak(k)*p_ref/725.0
+   ENDDO
+
+#endif
+      ptop = ak(1)
+      pint = ak(ks+1)
+
+ end subroutine set_eta
+
 #else
  !This is the version of set_eta used in fvGFS and AM4
  subroutine set_eta(km, ks, ptop, ak, bk, npz_type)
diff --git a/tools/fv_eta_mars.h b/tools/fv_eta_mars.h
new file mode 100644
index 0000000..d3c33ae
--- /dev/null
+++ b/tools/fv_eta_mars.h
@@ -0,0 +1,109 @@
+#ifdef MARS_GCM
+real a24(25),b24(25)            ! For Legacy grid
+real a37(38),b37(38)
+real a30(31),b30(31)
+real a56(57),b56(57)
+
+
+! Standard Grids for Mars [14July2022 ASB]
+          data a56 /      &
+            1.3563018554e-03, 6.7063018554e-03, 2.4241321588e-02, 5.9579139559e-02,  &
+            1.0136559389e-01, 1.6825499749e-01, 2.7298155063e-01, 4.3359212333e-01,  &
+            6.7517083742e-01, 1.0319369477e+00, 1.5492970168e+00, 2.0465542407e+00,  &
+            2.3680806130e+00, 2.5775313262e+00, 2.7138755632e+00, 2.8011848141e+00,  &
+            2.8544249882e+00, 2.8829273625e+00, 2.8924983792e+00, 2.8867229631e+00,  &
+            2.8677845297e+00, 2.8369915471e+00, 2.7951230781e+00, 2.7426603667e+00,  &
+            2.6799447585e+00, 2.6072863534e+00, 2.5250383250e+00, 2.4336462211e+00,  &
+            2.3336782332e+00, 2.2258404832e+00, 2.1109802625e+00, 1.9900795271e+00,  &
+            1.8642406009e+00, 1.7346658339e+00, 1.6026328225e+00, 1.4694666891e+00,  &
+            1.3365108017e+00, 1.2050971851e+00, 1.0765177308e+00, 9.5199715141e-01,  &
+            8.3266844952e-01, 7.1955149431e-01, 6.1353511520e-01, 5.1536294605e-01,  &
+            4.2562308332e-01, 3.4474146159e-01, 2.7297870058e-01, 2.1043003539e-01,  &
+            1.5702779957e-01, 1.1254577410e-01, 7.6604512139e-02, 4.8676435740e-02,  &
+            2.8088923499e-02, 1.4022366709e-02, 5.4970022270e-03, 1.3319303207e-03,  &
+            0.0000000000e+00/
+
+          data b56 /      &
+            0.0000000000e+00, 0.0000000000e+00, 0.0000000000e+00, 0.0000000000e+00,  &
+            0.0000000000e+00, 0.0000000000e+00, 0.0000000000e+00, 0.0000000000e+00,  &
+            0.0000000000e+00, 0.0000000000e+00, 0.0000000000e+00, 3.8959243224e-04,  &
+            1.5398265280e-03, 3.4859776279e-03, 6.3276882586e-03, 1.0211655864e-02,  &
+            1.5319232300e-02, 2.1856126398e-02, 3.0042710653e-02, 4.0104236295e-02,  &
+            5.2260765318e-02, 6.6716944495e-02, 8.3651935482e-02, 1.0320991147e-01,  &
+            1.2549155673e-01, 1.5054697772e-01, 1.7837036759e-01, 2.0889667263e-01,  &
+            2.4200040206e-01, 2.7749661130e-01, 3.1514398255e-01, 3.5464983214e-01,  &
+            3.9567679601e-01, 4.3785088608e-01, 4.8077057178e-01, 5.2401652319e-01,  &
+            5.6716165202e-01, 6.0978110361e-01, 6.5146188308e-01, 6.9181183906e-01,  &
+            7.3046777636e-01, 7.6710252154e-01, 8.0143081946e-01, 8.3321399362e-01,  &
+            8.6226335573e-01, 8.8844240001e-01, 9.1166786514e-01, 9.3190979178e-01,  &
+            9.4919074908e-01, 9.6358445368e-01, 9.7521407014e-01, 9.8425058294e-01,  &
+            9.9091181684e-01, 9.9546308366e-01, 9.9822145915e-01, 9.9956905812e-01,  &
+            1.0000000000e+00 /
+
+
+!------- Mars vertical levels -----------------------------
+      data a24 /  8.e-5,   0.,  0.,  0., 0.,   &
+                0., 0., 0., 0., 0.,   &
+                0., 0., 0., 0., 0.,   &
+                 0.,  0.,  0.,  0.,  0.,   &
+                 0.,  0.,  0.,   0.,     0.0000    /
+
+      data b24 / 0.000, 0.0001237, 0.0003423, 0.00073, 0.0014177,       &
+                 0.0026376, 0.0047998, 0.008657, 0.0143857, 0.0238144,       &
+                 0.0393587, 0.0649849, 0.1072458, 0.1768876, 0.2917842,       &
+                 0.4448475, 0.6020744, 0.7372935, 0.8585347, 0.9304322,       &
+                 0.974, 0.988, 0.996, 0.999, 1.0000000        /
+
+  data a30 /     &
+       2.0000000e-02,5.7381273e-02,1.9583981e-01,5.9229580e-01, &
+       1.5660228e+00,2.4454965e+00,2.7683755e+00,2.8851692e+00, &
+       2.9172228e+00,2.9087039e+00,2.8598939e+00,2.7687652e+00, &
+       2.6327054e+00,2.4509219e+00,2.2266811e+00,1.9684681e+00, &
+       1.6894832e+00,1.4055812e+00,1.1324258e+00,8.8289177e-01, &
+       6.6548467e-01,4.8401020e-01,3.3824119e-01,2.2510704e-01, &
+       1.3995719e-01,7.7611554e-02,3.3085503e-02,2.0000000e-03, &
+       2.0000000e-04,2.0000000e-06,0.0000000e+00  /
+
+  data b30 /      &
+       0.0000000e+00,0.0000000e+00,0.0000000e+00,0.0000000e+00, &
+       0.0000000e+00,1.9366394e-03,7.4419133e-03,1.6227267e-02, &
+       2.7075192e-02,4.3641000e-02,6.8106804e-02,1.0280240e-01, &
+       1.4971954e-01,2.0987133e-01,2.8270233e-01,3.6581610e-01, &
+       4.5520230e-01,5.4593599e-01,6.3310970e-01,7.1267629e-01, &
+       7.8196151e-01,8.3977530e-01,8.8620345e-01,9.2223168e-01, &
+       9.4934533e-01,9.6919618e-01,9.8337259e-01,9.9326941e-01, &
+       9.9600000e-01,9.9900000e-01,1.0000000e+00  /
+
+
+   data a37 /      &
+  2.0000000000e-03,  1.0000000000e-02,                    &
+  2.4215113043e-02,  4.6000346612e-02,  8.5702012910e-02, &
+  1.5659441036e-01,  2.8061882660e-01,  4.9318818941e-01, &
+  8.5008792314e-01,  1.4370449074e+00,  2.0054945771e+00, &
+  2.3335916338e+00,  2.5221957520e+00,  2.6264602874e+00, &
+  2.6762480591e+00,  2.6870173757e+00,  2.6657174771e+00, &
+  2.6140573091e+00,  2.5304052915e+00,  2.4110051828e+00, &
+  2.2508885698e+00,  2.0446940567e+00,  1.8074358726e+00, &
+  1.5511877409e+00,  1.2904762231e+00,  1.0396626704e+00, &
+  8.1055438393e-01,  6.1095195817e-01,  4.4434410651e-01, &
+  3.1051916267e-01,  2.0665632614e-01,  1.2848513437e-01, &
+  7.1249514632e-02,  3.0373097709e-02,  2.1040298410e-16, &
+  0.0000000,         0.00000000,                          &
+  0.0000000000e+00  /
+
+  data b37 /      &
+  0.0000000000e+00,  0.0000000000e+00,                    &
+  0.0000000000e+00,  0.0000000000e+00,  0.0000000000e+00, &
+  0.0000000000e+00,  0.0000000000e+00,  0.0000000000e+00, &
+  0.0000000000e+00,  0.0000000000e+00,  6.2833541661e-04, &
+  2.5671934940e-03,  6.0923860938e-03,  1.1725248117e-02, &
+  2.0238695380e-02,  3.2676843179e-02,  5.0373898012e-02, &
+  7.4959525687e-02,  1.0833815470e-01,  1.5263019875e-01, &
+  2.1006506655e-01,  2.8281982789e-01,  3.6584598427e-01, &
+  4.5513763376e-01,  5.4577516959e-01,  6.3285639147e-01, &
+  7.1233851133e-01,  7.8155013540e-01,  8.3930250332e-01, &
+  8.8568132228e-01,  9.2167127115e-01,  9.4875609753e-01, &
+  9.6858585131e-01,  9.8274719475e-01,  9.9326941371e-01, &
+  9.9600000e-01,     9.9900000e-01,                       &
+  1.0000000000e+00  /
+#endif
diff --git a/tools/fv_eta_venus.h b/tools/fv_eta_venus.h
new file mode 100644
index 0000000..7f7f7b9
--- /dev/null
+++ b/tools/fv_eta_venus.h
@@ -0,0 +1,35 @@
+#ifdef VENUS_GCM
+      real a50(51), b50(51)
+
+       data a50 / &
+          0.00000010869565, 0.00000066411131, 0.00000155378600, 0.00000307196430,  &
+          0.00000559748410, 0.00000865786490, 0.00001208302700, 0.00001686322300,  &
+          0.00002353452900, 0.00003284508400, 0.00004583901900, 0.00006397351100,  &
+          0.00008928224800, 0.00012460342000, 0.00017389813000, 0.00024269441000,  &
+          0.00033870732000, 0.00047270409000, 0.00065971149000, 0.00092070125000,  &
+          0.00128494170000, 0.00179328000000, 0.00250272310000, 0.00349283030000,  &
+          0.00487463590000, 0.00680310020000, 0.00949448820000, 0.01325062100000,  &
+          0.01849272900000, 0.02580867000000, 0.03575192000000, 0.04360806400000,  &
+          0.04724580000000, 0.04891368500000, 0.04912682400000, 0.04779955700000,  &
+          0.04488280300000, 0.04068075800000, 0.03553518700000, 0.02984945900000,  &
+          0.02404690900000, 0.01851416600000, 0.01355795600000, 0.00937562030000,  &
+          0.00605329780000, 0.00358216310000, 0.00188345090000, 0.00083402713000,  &
+          0.00028369645000, 0.00007132091600, 0.00000000000000  /
+
+      data b50  / &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000000000000, 0.00000000000000, 0.00000000000000,  &
+          0.00000000000000, 0.00000005382545, 0.00026699486563, 0.00666028808698,  &
+          0.02290928554681, 0.04899577982109, 0.08751637834259, 0.14290085869467,  &
+          0.21474170412983, 0.29863125317552, 0.39140024722511, 0.48881848341266,  &
+          0.58609291099510, 0.67851634714958, 0.76198545182255, 0.83348584823964,  &
+          0.89131068624888, 0.93508544124457, 0.96563140848759, 0.98471159261535,  &
+          0.99478675027412, 0.99868812493551, 1.00000000000000 /
+
+
+#endif
\ No newline at end of file
diff --git a/tools/fv_io.F90 b/tools/fv_io.F90
index 525abac..be268c4 100644
--- a/tools/fv_io.F90
+++ b/tools/fv_io.F90
@@ -45,7 +45,7 @@ module fv_io_mod
   use mpp_domains_mod,         only: domain2d, EAST, WEST, NORTH, CENTER, SOUTH, CORNER, &
                                      mpp_get_compute_domain, mpp_get_data_domain, &
                                      mpp_get_layout, mpp_get_ntile_count, &
-                                     mpp_get_global_domain
+                                     mpp_get_global_domain, mpp_update_domains
   use tracer_manager_mod,      only: tr_get_tracer_names=>get_tracer_names, &
                                      get_tracer_names, get_number_tracers, &
                                      set_tracer_profile, &
@@ -58,6 +58,8 @@ module fv_io_mod
   use fv_mp_mod,               only: mp_gather, is_master
   use fv_treat_da_inc_mod,     only: read_da_inc
 
+  use fv_surf_map_mod,   only: surfdrv
+
   implicit none
   private
 
@@ -656,7 +658,7 @@ contains
           if( is_master() ) write(*,*) 'Back from read_da_inc',pt_r(i,j,k)
        endif
 !      ====== end PJP added DA functionailty======
-
+       n = 1   ! mistakenly removed by GFDL? Urata 04/2022
        call rst_remap(npz_rst, npz, isc, iec, jsc, jec, isd, ied, jsd, jed, ntracers, ntprog,      &
                       delp_r,      u_r,      v_r,      w_r,      delz_r,      pt_r,  q_r,  qdiag_r,&
                       Atm(n)%delp, Atm(n)%u, Atm(n)%v, Atm(n)%w, Atm(n)%delz, Atm(n)%pt, Atm(n)%q, &
@@ -674,6 +676,14 @@ contains
     deallocate( q_r )
     deallocate( qdiag_r )
 
+       call surfdrv(Atm(1)%npx, Atm(1)%npy, Atm(1)%gridstruct%grid_64, Atm(1)%gridstruct%agrid_64,   &
+                    Atm(1)%gridstruct%area_64, Atm(1)%gridstruct%dx, Atm(1)%gridstruct%dy, Atm(1)%gridstruct%dxa, Atm(1)%gridstruct%dya, Atm(1)%gridstruct%dxc, Atm(1)%gridstruct%dyc, &
+                    Atm(1)%gridstruct%sin_sg, Atm(1)%phis, &
+                    Atm(1)%flagstruct%stretch_fac, Atm(1)%gridstruct%nested, Atm(1)%gridstruct%bounded_domain, &
+                    Atm(1)%neststruct%npx_global, Atm(1)%domain, Atm(1)%flagstruct%grid_number, Atm(1)%bd)
+       call mpp_update_domains( Atm(1)%phis, Atm(1)%domain )
+
+
     if ( (.not.Atm(1)%flagstruct%hydrostatic) .and. (.not.Atm(1)%flagstruct%make_nh) ) then
          deallocate ( w_r )
          deallocate ( delz_r )
diff --git a/tools/fv_mars_interface.F90 b/tools/fv_mars_interface.F90
new file mode 100644
index 0000000..3f75e0d
--- /dev/null
+++ b/tools/fv_mars_interface.F90
@@ -0,0 +1,85 @@
+ module fv_mars_interface_mod
+
+
+  use fv_arrays_mod,       only: fv_atmos_type, fv_nest_type, fv_grid_bounds_type
+
+!!   use mpp_mod,            only: mpp_error, FATAL, NOTE, mpp_pe
+!!   use mpp_parameter_mod,  only: AGRID_PARAM=>AGRID
+
+
+   implicit none
+   private
+
+
+   public   get_cubed_sphere_mars, grid, agrid, bd, npx_global, &
+            is, js, ie, je, isd, jsd, ied, jed
+
+
+
+   type(fv_grid_bounds_type), save :: bd
+
+   real, dimension(:,:,:),  allocatable, save  ::   grid
+   real, dimension(:,:,:),  allocatable, save  ::  agrid
+
+   integer, save :: is,  ie,  js,  je
+   integer, save :: isd, ied, jsd, jed
+   integer, save :: npx_global, ng
+   real,  save   :: stretch_fac
+
+contains
+
+
+
+  subroutine get_cubed_sphere_mars( Atm  )
+
+!!!    type(fv_atmos_type), intent(in), target :: Atm(:)
+    type(fv_atmos_type), intent(in) :: Atm
+
+!    type(fv_grid_bounds_type) :: bd
+
+!!!!      real, pointer, dimension(:,:,:) :: grid, agrid
+!!!!      real, dimension(:,:,:) :: grid, agrid
+
+  integer              ::  n
+  integer              ::  jbeg, jend
+
+!!!  integer :: is,  ie,  js,  je
+!!!  integer :: isd, ied, jsd, jed
+
+
+  n= 1
+
+  is  = Atm%bd%is
+  ie  = Atm%bd%ie
+  js  = Atm%bd%js
+  je  = Atm%bd%je
+  isd = Atm%bd%isd
+  ied = Atm%bd%ied
+  jsd = Atm%bd%jsd
+  jed = Atm%bd%jed
+
+  allocate (  grid(isd:ied+1,jsd:jed+1,2) )
+  allocate ( agrid(isd:ied  ,jsd:jed  ,2) )
+
+  grid  = Atm%gridstruct%grid
+  agrid = Atm%gridstruct%agrid
+
+!!  grid  => Atm(1)%gridstruct%grid
+!!  agrid => Atm(1)%gridstruct%agrid
+
+
+  bd=          Atm%bd
+  stretch_fac= Atm%flagstruct%stretch_fac
+  npx_global=  Atm%neststruct%npx_global
+
+
+!!   write(*,*) '  Mars interface:  Cube indices: bd struct ', bd%is, bd%ie, bd%js, bd%je, bd
+
+!!   write(*,*) '  Mars interface:  npx_global, stretch ', npx_global, stretch_fac
+
+
+ end subroutine get_cubed_sphere_mars
+
+
+
+ end module  fv_mars_interface_mod
diff --git a/tools/fv_surf_map.F90 b/tools/fv_surf_map.F90
index 84252be..9a889fb 100644
--- a/tools/fv_surf_map.F90
+++ b/tools/fv_surf_map.F90
@@ -26,6 +26,10 @@
       use mpp_mod,           only: get_unit, input_nml_file, mpp_error
       use mpp_domains_mod,   only: mpp_update_domains, domain2d
       use constants_mod,     only: grav, radius, pi=>pi_8
+#ifdef MARS_GCM
+      use fms_mod,           only: read_data
+      use fms_io_mod,        only: field_size
+#endif
 
       use fv_grid_utils_mod, only: great_circle_dist, latlon2xyz, v_prod, normalize_vect
       use fv_grid_utils_mod, only: g_sum, global_mx, vect_cross
@@ -67,8 +71,15 @@
       integer:: n_del4 = -1
 
 
+#ifdef MARS_GCM
+      character(len=128)::  surf_file = "INPUT/mars_topo.nc"
+      character(len=6)  ::  surf_format = 'netcdf'
+      character(len=80) :: field_name
+      integer           :: fld_dims(4)
+#else
       character(len=128)::  surf_file = "INPUT/topo1min.nc"
       character(len=6)  ::  surf_format = 'netcdf'
+#endif
       logical :: namelist_read = .false.
 
       real(kind=R_GRID) da_min
@@ -83,6 +94,9 @@
       public  sgh_g, oro_g, zs_g
       public  surfdrv
       public  del2_cubed_sphere, del4_cubed_sphere, FV3_zs_filter
+#ifdef MARS_GCM
+      public  map_to_cubed_simple
+#endif
 
       contains
 
@@ -172,6 +186,23 @@
       if (grid_number > 1) write(grid_string, '(A, I1)') ' g', grid_number
 
 
+#ifdef MARS_GCM
+      if (file_exists(surf_file)) then
+         field_name = 'topo'
+
+         status = nf_open (surf_file, NF_NOWRITE, ncid)
+         if (status .ne. NF_NOERR) call handle_err(status)
+
+         call field_size( trim(surf_file), trim(field_name), fld_dims )
+         nlon= fld_dims(1);  nlat= fld_dims(2);
+
+         if(is_master()) write(*,*) 'Mars Terrain dataset dims=', nlon, nlat
+
+      else
+         call error_mesg ( 'surfdrv', 'mars_topo not found in INPUT', FATAL )
+      endif
+
+#else
 !
 ! surface file must be in NetCDF format
 !
@@ -207,6 +238,7 @@
     else
        call error_mesg ( 'surfdrv','surface file '//trim(surf_file)//' not found !', FATAL )
     endif
+#endif
 
       allocate ( lat1(nlat+1) )
       allocate ( lon1(nlon+1) )
@@ -284,6 +316,16 @@
          if (is_master()) write(*,*) 'Terrain dataset =', nlon, 'jt=', jt
          if (is_master()) write(*,*) 'igh (terrain ghosting)=', igh
 
+
+#ifdef MARS_GCM
+         nread = 1;   start = 1
+         nread(1) = nlon
+         start(2) = jstart; nread(2) = jend - jstart + 1
+
+         allocate ( ft(-igh:nlon+igh,jt) )
+         ft(1:nlon,1:jt)= 1.0    ! all land points
+
+#else
          status = nf_inq_varid (ncid, 'ftopo', ftopoid)
          if (status .ne. NF_NOERR) call handle_err(status)
          nread = 1;   start = 1
@@ -293,6 +335,7 @@
          allocate ( ft(-igh:nlon+igh,jt) )
          status = nf_get_vara_real (ncid, ftopoid, start, nread, ft(1:nlon,1:jt))
          if (status .ne. NF_NOERR) call handle_err(status)
+#endif
 
          do j=1,jt
             do i=-igh,0
@@ -303,7 +346,12 @@
             enddo
          enddo
 
+
+#ifdef MARS_GCM
+         status = nf_inq_varid (ncid, trim(field_name), htopoid)
+#else
          status = nf_inq_varid (ncid, 'htopo', htopoid)
+#endif
          if (status .ne. NF_NOERR) call handle_err(status)
          allocate ( zs(-igh:nlon+igh,jt) )
          status = nf_get_vara_real (ncid, htopoid, start, nread, zs(1:nlon,1:jt))
@@ -1486,6 +1534,232 @@
  end function inside_p4
 #endif
 
+
+#ifdef MARS_GCM
+
+ logical function inside_p4_old(p1, p2, p3, p4, pp)
+!
+!            4----------3
+!           /          /
+!          /    pp    /
+!         /          /
+!        1----------2
+!
+! A * B = |A| |B| cos(angle)
+
+      real, intent(in):: p1(3), p2(3), p3(3), p4(3)
+      real, intent(in):: pp(3)
+! Local:
+      real v1(3), v2(3), vp(3)
+      real a1, a2, aa, s1, s2, ss
+      integer k
+
+! S-W:
+      do k=1,3
+         v1(k) = p2(k) - p1(k)
+         v2(k) = p4(k) - p1(k)
+         vp(k) = pp(k) - p1(k)
+      enddo
+      s1 = sqrt( v1(1)**2 + v1(2)**2 + v1(3)**2 )
+      s2 = sqrt( v2(1)**2 + v2(2)**2 + v2(3)**2 )
+      ss = sqrt( vp(1)**2 + vp(2)**2 + vp(3)**2 )
+
+! Compute cos(angle):
+      aa = v_prod(v1, v2) / (s1*s2)
+      a1 = v_prod(v1, vp) / (s1*ss)
+      a2 = v_prod(v2, vp) / (s2*ss)
+
+      if ( a1<aa  .or.  a2<aa ) then
+           inside_p4_old = .false.
+           return
+      endif
+
+! N-E:
+      do k=1,3
+         v1(k) = p2(k) - p3(k)
+         v2(k) = p4(k) - p3(k)
+         vp(k) = pp(k) - p3(k)
+      enddo
+      s1 = sqrt( v1(1)**2 + v1(2)**2 + v1(3)**2 )
+      s2 = sqrt( v2(1)**2 + v2(2)**2 + v2(3)**2 )
+      ss = sqrt( vp(1)**2 + vp(2)**2 + vp(3)**2 )
+
+! Compute cos(angle):
+      aa = v_prod(v1, v2) / (s1*s2)
+      a1 = v_prod(v1, vp) / (s1*ss)
+      a2 = v_prod(v2, vp) / (s2*ss)
+
+      if ( a1<aa  .or.  a2<aa ) then
+           inside_p4_old = .false.
+      else
+           inside_p4_old = .true.
+      endif
+
+ end function inside_p4_old
+
+    subroutine map_to_cubed_simple(im, jm, lat1, lon1, q1, grid, agrid, q2, npx, npy, npx_global, bd)
+
+
+! Input
+      type(fv_grid_bounds_type), intent(IN) :: bd
+      integer, intent(in):: im,jm         ! original dimensions
+      integer, intent(in):: npx, npy, npx_global
+!rjw      logical, intent(in):: master
+      real, intent(in):: lat1(jm+1)       ! original southern edge of the cell [-pi/2:pi/2]
+      real, intent(in):: lon1(im+1)       ! original western edge of the cell [0:2*pi]
+      real(kind=4), intent(in):: q1(im,jm)        ! original data at center of the cell
+!rjw      real(kind=4), intent(in):: f1(im,jm)        !
+
+      real, intent(in)::  grid(bd%isd:bd%ied+1, bd%jsd:bd%jed+1,2)
+      real, intent(in):: agrid(bd%isd:bd%ied,   bd%jsd:bd%jed,  2)
+
+! Output
+      real, intent(out):: q2(bd%isd:bd%ied, bd%jsd:bd%jed) ! Mapped data at the target resolution
+!rjw      real, intent(out):: f2(bd%isd:bd%ied,bd%jsd:bd%jed) ! oro
+!rjw      real, intent(out):: h2(bd%isd:bd%ied,bd%jsd:bd%jed) ! variances of terrain
+
+! Local
+      real(kind=4)  qt(-im/32:im+im/32,jm)    ! ghosted east-west
+!rjw      real(kind=4)  ft(-im/32:im+im/32,jm)    !
+      real lon_g(-im/32:im+im/32)
+      real lat_g(jm)
+
+      real pc(3), p2(2), pp(3), grid3(3,bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
+      integer i,j, np
+      integer ii, jj, i1, i2, j1, j2
+      integer ifirst, ilast
+      real ddeg, latitude, qsum, fsum, hsum, lon_w, lon_e, lat_s, lat_n, r2d
+      real delg
+
+      integer :: is,  ie,  js,  je
+      integer :: isd, ied, jsd, jed
+
+      is  = bd%is
+      ie  = bd%ie
+      js  = bd%js
+      je  = bd%je
+      isd = bd%isd
+      ied = bd%ied
+      jsd = bd%jsd
+      jed = bd%jed
+
+!!!      pi = 4.0 * datan(1.0d0)
+
+      r2d = 180./pi
+      ddeg = 2.*pi/real(4*npx_global)
+
+! Ghost the input coordinates:
+      do i=1,im
+         lon_g(i) = 0.5*(lon1(i)+lon1(i+1))
+      enddo
+
+      do i=-im/32,0
+         lon_g(i) = lon_g(i+im)
+      enddo
+      do i=im+1,im+im/32
+         lon_g(i) = lon_g(i-im)
+      enddo
+
+      do j=1,jm
+         lat_g(j) = 0.5*(lat1(j)+lat1(j+1))
+      enddo
+
+      if ( 2*(im/2) /= im ) then
+           write(*,*) 'Warning: Terrain datset must have an even nlon dimension'
+      endif
+! Ghost Data
+      do j=1,jm
+         do i=1,im
+            qt(i,j) = q1(i,j)
+!rjw            ft(i,j) = f1(i,j)
+         enddo
+         do i=-im/32,0
+            qt(i,j) = qt(i+im,j)
+!rjw            ft(i,j) = ft(i+im,j)
+         enddo
+         do i=im+1,im+im/32
+            qt(i,j) = qt(i-im,j)
+!rjw            ft(i,j) = ft(i-im,j)
+         enddo
+      enddo
+
+      do j=js,je+1
+         do i=is,ie+1
+            call latlon2xyz(grid(i,j,1:2), grid3(1,i,j))
+         enddo
+      enddo
+
+!rjw     if(is_master()) write(*,*) 'surf_map: Search started ....'
+! Mapping:
+      do j=js,je
+         do i=is,ie
+! Determine the approximate local loop bounds (slightly larger than needed)
+            lon_w = min( grid(i,j,1), grid(i+1,j,1), grid(i,j+1,1), grid(i+1,j+1,1) ) - ddeg
+            lon_e = max( grid(i,j,1), grid(i+1,j,1), grid(i,j+1,1), grid(i+1,j+1,1) ) + ddeg
+            if ( (lon_e - lon_w) > pi ) then
+                 delg = max( abs(lon_e-2.*pi), abs(lon_w) ) + ddeg
+                 i1 = -delg / (2.*pi/real(im)) - 1
+                 i2 = -i1 + 1
+            else
+                 i1 = lon_w / (2.*pi/real(im)) - 1
+                 i2 = lon_e / (2.*pi/real(im)) + 2
+            endif
+            i1 = max(-im/32, i1)
+            i2 = min(im+im/32, i2)
+!
+            lat_s = min( grid(i,j,2), grid(i+1,j,2), grid(i,j+1,2), grid(i+1,j+1,2) ) - ddeg
+            lat_n = max( grid(i,j,2), grid(i+1,j,2), grid(i,j+1,2), grid(i+1,j+1,2) ) + ddeg
+            j1 = (0.5*pi + lat_s) / (pi/real(jm)) - 1
+            j2 = (0.5*pi + lat_n) / (pi/real(jm)) + 2
+
+              np = 0
+            qsum = 0.
+!rjw            fsum = 0.
+!rjw            hsum = 0.
+!           call latlon2xyz(agrid(i,j,1:2), pc)
+
+!rjw             print *, 'Interior loop:  ',  i, j, i1, i2, j1, j2,  grid(i,j,1:2)*r2d,  agrid(i,j,1:2)*r2d
+
+            do jj=max(1,j1),min(jm,j2)
+                  p2(2) = lat_g(jj)
+                  latitude =  p2(2)*r2d
+               if ( abs(latitude) > 80.  ) then
+                  ifirst = 1; ilast = im
+               else
+                  ifirst = i1; ilast = i2
+               endif
+
+               do ii=ifirst, ilast
+                  p2(1) = lon_g(ii)
+                  call latlon2xyz(p2, pp)
+                  if (inside_p4_old(grid3(1,i,j), grid3(1,i+1,j), grid3(1,i+1,j+1), grid3(1,i,j+1), pp)) then
+                       np = np + 1
+                       qsum = qsum + qt(ii,jj)
+!rjw                       fsum = fsum + ft(ii,jj)
+!rjw                       hsum = hsum + qt(ii,jj)**2
+                  endif
+
+               enddo
+            enddo
+! Compute weighted average:
+            if ( np > 0 ) then
+                 q2(i,j) = qsum / real(np)
+!rjw                 f2(i,j) = fsum / real(np)
+!rjw                 h2(i,j) = hsum / real(np) - q2(i,j)**2
+            else                    ! the subdomain could be totally flat
+!rjw            if(is_master()) write(*,*) 'Warning: surf_map failed'
+                call error_mesg ( 'map_to_cubed_simple', 'surf_map_simple failed', FATAL )
+                q2(i,j) = 1.E8
+
+            endif
+         enddo
+      enddo
+      end subroutine map_to_cubed_simple
+
+
+#endif
+
+
  subroutine handle_err(status)
 #include <netcdf.inc>
       integer          status
diff --git a/tools/fv_timing.F90 b/tools/fv_timing.F90
index 3740a7a..ec820b9 100644
--- a/tools/fv_timing.F90
+++ b/tools/fv_timing.F90
@@ -1,26 +1,5 @@
-!***********************************************************************
-!*                   GNU Lesser General Public License
-!*
-!* This file is part of the FV3 dynamical core.
-!*
-!* The FV3 dynamical core is free software: you can redistribute it
-!* and/or modify it under the terms of the
-!* GNU Lesser General Public License as published by the
-!* Free Software Foundation, either version 3 of the License, or
-!* (at your option) any later version.
-!*
-!* The FV3 dynamical core is distributed in the hope that it will be
-!* useful, but WITHOUT ANYWARRANTY; without even the implied warranty
-!* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-!* See the GNU General Public License for more details.
-!*
-!* You should have received a copy of the GNU Lesser General Public
-!* License along with the FV3 dynamical core.
-!* If not, see <http://www.gnu.org/licenses/>.
-!***********************************************************************
       module fv_timing_mod
 
-      use mpp_mod, only: mpp_error, FATAL
 #if defined(SPMD)
       use fv_mp_mod, only: is_master, mp_reduce_max
 #endif
@@ -37,10 +16,10 @@
       integer , private      :: tblk
 
 #if defined(SPMD)
-      real(kind=8) , external       :: MPI_Wtime
+      real , external       :: MPI_Wtime
 #endif
       real , private       :: etime
-      real(kind=8) , private       :: totim
+      real , private       :: totim
       real , private       :: tarray(2)
       type tms
            private
@@ -53,7 +32,9 @@
       real , private       :: us_tmp1(nblks,2)
       real , private       :: us_tmp2(nblks,2)
 
-      logical, private :: module_initialized = .false.
+!---- version number -----
+      character(len=128) :: version = '$Id: fv_timing.F90,v 17.0.2.2.2.3.2.1 2013/01/24 18:16:53 Lucas.Harris Exp $'
+      character(len=128) :: tagname = '$Name: siena_201305 $'
 
       contains
          subroutine timing_init
@@ -67,7 +48,6 @@
 
          integer  n
 
-         if ( module_initialized ) return
 
          tblk=0
          do n = 1, nblks
@@ -92,7 +72,6 @@
 #   endif
 #endif
 
-         module_initialized = .true.
          end subroutine timing_init
 
 
@@ -117,10 +96,6 @@
 
          integer ierr
 
-         if ( .not. module_initialized ) then
-            call timing_init()
-         end if
-
          UC_blk_name = blk_name
 
          call upper(UC_blk_name,len_trim(UC_blk_name))
@@ -196,7 +171,6 @@
 
 !         write(*,*) 'timing_off ', ctmp, tblk, tblk
         if ( iblk .eq. 0 ) then
-            call mpp_error(FATAL,'fv_timing_mod: timing_off called before timing_on for: '//trim(blk_name))
 !           write(*,*) 'stop in timing off in ', ctmp
 !           stop
         endif
@@ -269,13 +243,13 @@
         print *,                                  &
         '  -----------------------------------------------------'
         print *,                                  &
-        '     Block                    User time  System Time   Total Time   GID '
+        '     Block          User time  System Time   Total Time'
         print *,                                  &
         '  -----------------------------------------------------'
 
         do n = 1, tblk
-           print '(3x,a20,2x,3(1x,f12.4), 2x, I6)', blkname(n),     &
-               tmp(n)%usr, tmp(n)%sys, tmp(n)%usr + tmp(n)%sys, gid
+           print '(3x,a20,2x,3(1x,f12.4))', blkname(n),     &
+               tmp(n)%usr, tmp(n)%sys, tmp(n)%usr + tmp(n)%sys
         end do
 
 
diff --git a/tools/init_hydro.F90 b/tools/init_hydro.F90
index 8bcc995..61de2be 100644
--- a/tools/init_hydro.F90
+++ b/tools/init_hydro.F90
@@ -22,7 +22,7 @@
 
 module init_hydro_mod
 
-      use constants_mod,      only: grav, rdgas, rvgas
+      use constants_mod,      only: grav, rdgas, rvgas, cp_air
       use fv_grid_utils_mod,  only: g_sum
       use fv_mp_mod,          only: is_master
       use field_manager_mod,  only: MODEL_ATMOS
@@ -34,6 +34,12 @@ module init_hydro_mod
       implicit none
       private
 
+!  some new variables for Mars atm init
+      real   :: isotemp
+      logical:: do_isothermal
+
+      public :: isotemp, do_isothermal
+
       public :: p_var, hydro_eq
 
 contains
@@ -306,8 +312,79 @@ contains
   real p0, gztop, ptop
   integer  i,j,k
 
+!local variables for non-isothermal initialization
+  real tsat,localp
+
   if ( is_master() ) write(*,*) 'Initializing ATM hydrostatically'
 
+#if defined(MARS_GCM)
+  if ( is_master() ) write(*,*) 'Initializing Mars'
+      p0 = 0.8*drym         !
+      t0 = isotemp        ! originally 200 Urata 2/6/2019
+
+!         Isothermal temperature
+      pt = t0
+
+      gztop = rdgas*t0*log(p0/ak(1))        ! gztop when zs==0
+
+     do j=js,je
+        do i=is,ie
+           ps(i,j) = ak(1)*exp((gztop-hs(i,j))/(rdgas*t0))
+        enddo
+     enddo
+
+
+     psm = g_sum(domain, ps(is:ie,js:je), is, ie, js, je, ng, area, 1, .true.)
+     dps = drym - psm
+
+     if(is_master()) write(*,*) 'Initializing:  Computed mean ps=', psm
+     if(is_master()) write(*,*) '            Correction delta-ps=', dps
+
+!           Add correction to surface pressure to yield desired
+!                globally-integrated atmospheric mass  (drym)
+     do j=js,je
+        do i=is,ie
+           ps(i,j) = ps(i,j) + dps*(log(ps(i,j))/log(drym))
+        enddo
+     enddo
+
+      do j=js,je
+         do i=is,ie
+            localp=0.
+            do k=1,km
+               delp(i,j,k) = ak(k+1)-ak(k) + ps(i,j)*(bk(k+1)-bk(k))
+               if (.not.(do_isothermal)) then
+                  localp=localp+delp(i,j,k)
+                  tsat=3182.48D0/(23.3494D0-log(localp*0.01))
+                  pt(i,j,k) = max(tsat,pt(i,j,k)+(grav/cp_air)*11100.*log(localp/ps(i,j)))
+               endif
+            enddo
+         enddo
+      enddo
+
+#elif defined(VENUS_GCM)
+  if ( is_master() ) write(*,*) 'Initializing Venus'
+      p0 = 92.E5         ! need to tune this value
+      t0 = 700.
+      pt = t0
+! gztop when zs==0
+      gztop = rdgas*t0*log(p0/ak(1))
+
+     do j=js,je
+        do i=is,ie
+           ps(i,j) = ak(1)*exp((gztop-hs(i,j))/(rdgas*t0))
+        enddo
+     enddo
+
+      do k=1,km
+         do j=js,je
+            do i=is,ie
+               delp(i,j,k) = ak(k+1)-ak(k) + ps(i,j)*(bk(k+1)-bk(k))
+            enddo
+         enddo
+      enddo
+
+#else
   if ( is_master() ) write(*,*) 'Initializing Earth'
 ! Given p1 and z1 (250mb, 10km)
         p1 = 25000.
@@ -448,7 +525,7 @@ contains
       endif
 
    enddo    ! j-loop
-
+#endif MARS_GCM
 
  end subroutine hydro_eq
 
diff --git a/tools/test_cases.F90 b/tools/test_cases.F90
index e162f53..8fbe58e 100644
--- a/tools/test_cases.F90
+++ b/tools/test_cases.F90
@@ -36,7 +36,7 @@
                                    hybrid_z_dz
 
       use mpp_mod,           only: mpp_error, FATAL, mpp_root_pe, mpp_broadcast, mpp_sum
-      use mpp_mod,           only: stdlog, input_nml_file
+      use mpp_mod,           only: stdlog, input_nml_file, NOTE
       use fms_mod,           only: check_nml_error
       use mpp_domains_mod,   only: mpp_update_domains, domain2d
       use mpp_parameter_mod, only: AGRID_PARAM=>AGRID,CGRID_NE_PARAM=>CGRID_NE, &
@@ -47,7 +47,10 @@
      use mpp_mod, only: mpp_pe, mpp_chksum, stdout
 !!! END DEBUG CODE
       use fv_arrays_mod,         only: fv_grid_type, fv_flags_type, fv_grid_bounds_type, R_GRID
-      use tracer_manager_mod,    only: get_tracer_index
+      use tracer_manager_mod,    only: tr_get_tracer_names=>get_tracer_names, &
+                                     get_tracer_names, get_number_tracers, &
+                                     set_tracer_profile, &
+                                     get_tracer_index
       use field_manager_mod,     only: MODEL_ATMOS
       implicit none
       private
@@ -655,6 +658,9 @@
 
       integer :: is, ie, js, je
       integer :: isd, ied, jsd, jed
+!tracer init
+      character(len=64)    :: tracer_name
+      integer :: ntracers
 
       is  = bd%is
       ie  = bd%ie
@@ -1533,11 +1539,17 @@
          alpha = 0.
 
    ! Initialize dry atmosphere
-         q(:,:,:,:) = 3.e-6
+         q(:,:,:,:) = 0.e-6
          u(:,:,:) = 0.0
          v(:,:,:) = 0.0
          if (.not.hydrostatic) w(:,:,:)= 0.0
+         ntracers = size(q,4)
+         DO nt = 1, ntracers
+           call get_tracer_names(MODEL_ATMOS, nt, tracer_name)
 
+           call set_tracer_profile (MODEL_ATMOS, nt, q(is:ie,js:je,:,nt)  )
+           call mpp_error(NOTE,'==>  Setting tracer '//trim(tracer_name)//' from set_tracer')
+         ENDDO
        if ( test_case==14 ) then
 ! Aqua-planet case: mean SLP=1.E5
          phis = 0.0
@@ -1545,7 +1557,11 @@
                        delp, ak, bk, pt, delz, area, ng, .false., hydrostatic, hybrid_z, domain)
        else
 ! Initialize topography
+#ifdef MARS_GCM
+         gh0  = 0.*Grav
+#else
          gh0  = 5960.*Grav
+#endif MARS_GCM
          phis = 0.0
          r0 = PI/9.
          p1(1) = PI/4.
@@ -1597,7 +1613,14 @@
        u = 0.
        v = 0.
        q(:,:,:,:) = 0.
-       q(:,:,:,1) = 3.e-6
+!       q(:,:,:,1) = 3.e-6
+       ntracers = size(q,4)  ! Temporary until we get tracer manager integrated
+        DO nt = 1, ntracers
+           call get_tracer_names(MODEL_ATMOS, nt, tracer_name)
+
+           call set_tracer_profile (MODEL_ATMOS, nt, q(is:ie,js:je,:,nt)  )
+           call mpp_error(NOTE,'==>  Setting tracer '//trim(tracer_name)//' from set_tracer')
+        ENDDO
 
        call hydro_eq(npz, is, ie, js, je, ps, phis, dry_mass,  &
                      delp, ak, bk, pt, delz, area, ng, mountain, hydrostatic, hybrid_z, domain)
@@ -2697,7 +2720,7 @@
          enddo
          enddo
          enddo
-
+#ifndef MARS_GCM
       else if ( abs(test_case)==30 .or.  abs(test_case)==31 ) then
 !------------------------------------
 ! Super-Cell; with or with rotation
@@ -2856,7 +2879,7 @@
               enddo
            endif
         enddo
-
+#endif MARS_GCM
      elseif (test_case == 32) then
 
         call mpp_error(FATAL, ' test_case 32 not yet implemented')
@@ -6467,7 +6490,7 @@ end subroutine terminator_tracers
                enddo
             enddo
           enddo
-
+#ifndef MARS_GCM
       case ( 17 )
 !---------------------------
 ! Doubly periodic SuperCell, straight wind (v==0)
@@ -6665,7 +6688,7 @@ end subroutine terminator_tracers
                endif
             enddo
          endif
-
+#endif MARS_GCM
         case ( 101 )
 
 ! IC for LES
@@ -7149,7 +7172,7 @@ end subroutine terminator_tracers
 
  end subroutine superK_u
 
-
+#ifndef MARS_GCM
  subroutine SuperCell_Sounding(km, ps, pk1, tp, qp)
  use gfdl_cloud_microphys_mod, only: wqsat_moist, qsmith_init, qs_blend
 ! Morris Weisman & J. Klemp 2002 sounding
@@ -7280,6 +7303,7 @@ end subroutine terminator_tracers
 #endif
 
  end subroutine SuperCell_Sounding
+#endif
 
  subroutine DCMIP16_BC(delp,pt,u,v,q,w,delz,&
       is,ie,js,je,isd,ied,jsd,jed,npz,nq,ak,bk,ptop, &
